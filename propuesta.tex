\chapter{Propuesta}

En este trabajo se propone realizar la implementación en Dart de un sistema de inferencia de facetas de desclasificación, que incluya el análisis de \textit{Type-based declassification}, mediante la realización de un plugin para entornos de desarrollo integrado (IDE). En este capítulo se detalla el problema de inferencia a resolver y las estrategias utilizadas para resolverlo.

\section{Problema de inferencia}
Para la formulación del problema, es posible asumir que la información de las facetas privadas de type-based declassification se encuentra a disposición, debido a que algunos lenguajes de programación poseen herramientas para obtener dicha información.

\begin{defn}[Problema de inferencia]
  Dado un programa parcialmente tipado con facetas de desclasificación, y completamente tipado con facetas privadas, encontrar la faceta de desclasificación de las expresiones no tipadas que más se ajuste al uso de las expresiones, tal que se cumplan las reglas del sistema de tipos de type-based declassification.
\end{defn}

A continuación, se muestran algunos ejemplos con casos que no fueron cubiertos en el capítulo 2, con el objetivo de ilustrar la solución esperada al problema de inferencia.

\begin{ej} \ \\
  \normalfont
\begin{lstlisting}
  bool login(String<Top password, String guess) {
    return password.eq(guess);
  }
\end{lstlisting}
\end{ej}


En este ejemplo, se quiere inferir que el método \texttt{login} tiene a \texttt{Top} como faceta de desclasificación, debido a la aplicación de la regla \texttt{TmH} de type-based declassification.

\begin{ej} \ \\
  \normalfont
\begin{lstlisting}
  bool login(String password, String guess) {
    return password.hash().eq(guess);
  }
\end{lstlisting}
\end{ej}

En este caso ocurrió un encadenamiento de llamadas a métodos sobre \texttt{password}. La faceta de desclasificación para \texttt{password} que resuelve el problema de inferencia contiene al método \texttt{hash}, al cual se le infiere una faceta de desclasificación de retorno que contiene al método \texttt{eq}. Si se declara una faceta de desclasificación de retorno para el método \texttt{eq}, entonces se infere esa misma faceta para el retorno del método \texttt{login}, por la aplicación de la regla \texttt{TmD} de type-based declassification.

\begin{ej} \ \\
  \normalfont
\begin{lstlisting}
  void check(String<Bot s);

  bool<Top login(String<Top password, String guess) {
    check(password);
    return password.eq(guess);
  }
\end{lstlisting}
\end{ej}

En este caso, se debe reportar un error de flujo en el llamado a la función \texttt{check}, debido a que la faceta del argumento debe ser subtipo de la faceta del parámetro, esto es, \texttt{Top <: Bot} es una relación no válida.

\section{Consideraciones de diseño}

Se debe tomar una decisión acerca de las facetas de desclasificación de los métodos que pertenecen al \textit{core} de un lenguaje de programación. Para ilustrar la necesidad de esta decisión, veamos el siguiente ejemplo:

\begin{lstlisting}
  int<Bot getLength(String password) {
    return password.length
  }
\end{lstlisting}

Este método será aceptado o rechazado por las reglas del sistema de tipos, si la faceta de desclasificación de retorno del campo \texttt{length} es \texttt{Bot} o \texttt{Top} respectivamente.

Si decidimos que la faceta de desclasificación de retorno para métodos del \texttt{core} del lenguaje es \texttt{Top}, entonces cualquier operación que realicemos sobre el valor de retorno, retornará \texttt{Top}, lo cual es poco útil. Por lo tanto la decisión por defecto es que la faceta de desclasificación de retorno para métodos del \textit{core} del lenguaje sea \texttt{Bot}.

Ahora, analicemos ambas posibilidades para la faceta de desclasificación por defecto de los parámetros:

\begin{itemize}
  \item \texttt{Top} $\rightarrow$ \texttt{Bot}: Supongamos que el \textit{core} del lenguaje posee un método \texttt{identity}, que dado un \texttt{x}, retorna \texttt{x}. Si tomamos esta decisión, entonces el método \texttt{identity} podrá ser usado como desclasificador universal, como por ejemplo \texttt{identity(password)}.
  \item \texttt{Bot} $\rightarrow$ \texttt{Bot}: Esta elección restringe las facetas de desclasificación de los argumentos utilizados a \texttt{Bot}, lo cual también podría ser considerado poco útil. Sin embargo, al retornar un valor con faceta de desclasificación \texttt{Bot}, cualquier operación podrá ser utilizada sobre ese valor.
\end{itemize}

Haciendo un balance, se considera que la opción \texttt{Bot} $\rightarrow$ \texttt{Bot} tiene el mejor equilibrio entre utilidad y seguridad, por lo que es la opción por defecto considerada. Sin embargo, es deseable que la herramienta se pueda configurar para elegir otra alternativa.

\section{Gramática de tipos}
Como se vió en la sección \ref{inference}, es necesario introducir variables de tipo para presentar un algoritmo de inferencia basado en constraints. Además, se deben definir los otros tipos que serán utilizados internamente en el análisis. Esto se hace definiendo la gramática de tipos que usará el sistema de inferencia:

  $\mathtt{\tau := \alpha\ |\ Obj(\overline{l: \tau})\ |\ [\overline{\tau}] \rightarrow \tau \ |\ Join(\overline{\tau})\ |\ Meet(\overline{\tau})\ |\ Bot\ |\ Top}$

Donde $\alpha$ es cualquier variable de tipo, $\mathtt{Obj(\overline{l: \tau}})$ representa el tipo de un objeto y $\mathtt{l}$ es un nombre de método.

\section{Generación de constraints de subtyping} \label{propuestaGen}
Como se mencionó en la sección \ref{constraints}, el uso de constraints permite presentar un algoritmo de inferencia como una fase de generación de constraints, y una fase de resolución de constraints. En el algoritmo \ref{pseudogen} se muestra la generación de constraints para un nodo determinado del árbol de sintaxis abstracta (AST).

Es importante notar que la constraint generada por la invocación a un método almacena el tipo de la expresión, debido a la posible aplicación de la regla \texttt{TmH} del sistema de tipos de type-based declassification.
\clearpage % TODO
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Generación de constraints}
  \label{pseudogen}
    \begin{algorithmic}[1]
      \Function{Constraint\_Generation}{\texttt{node, pc}}
          \State $\mathtt{cs\gets \{\}}$
          \Switch{\texttt{node}}
            \Case{\texttt{MethodInvocation(name, target, signature, expression, arguments)}}
              \State \texttt{cs.insert(target <: Obj(name: signature), expression)}
              \For {$\mathtt{argument,correspondingParameter\ \mathbf{in}\ arguments}$}
                \State \texttt{cs.insert(argument <: correspondingParameter})
              \EndFor
            \EndCase
            \Case{\texttt{ReturnStatement(expression, methodReturn)}}
              \State \texttt{cs.insert(expression <: methodReturn)}
              \State \texttt{cs.insert(pc <: methodReturn)}
            \EndCase
            \Case{\texttt{AssignmentExpression(leftHand, rightHand)}}
              \State \texttt{cs.insert(rightHand <: LeftHand)}
              \State \texttt{cs.insert(pc <: LeftHand)}
            \EndCase
            \Case{\texttt{IfExpression(conditionExpression)}}
              \State $\mathtt{pc\gets conditionExpression}$
            \EndCase
          \EndSwitch
          \State \Return \texttt{cs, pc}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
Ejecutando la función del algoritmo \ref{pseudogen} en todos los nodos del AST y uniendo los resultados, se obtiene el set de constraints.

A modo de ejemplo, se muestran las constraints generadas para el ejemplo \ref{ej2-5}.

\begin{ej}\ \\
  \label{ej3-1}
  \begin{enumerate}
    \item $\mathtt{\{\alpha <: Obj(eq : [Bot] \rightarrow Bot),\ \beta\}}$
    \item $\mathtt{\{\alpha <: Obj(hash : [\ ] \rightarrow Bot),\ \gamma\}}$
    \item $\mathtt{\{Bot <: Bot\}}$
    \item $\mathtt{\{Bot <: Bot\}}$
    \item $\mathtt{\{\gamma <: Bot\}}$
    \item $\mathtt{\{Bot <: Bot\}}$
  \end{enumerate}
\end{ej}


Las constraints 1 y 2 se generan por las llamadas a métodos sobre el parámetro \texttt{password} ($\alpha$). Las constraints 3 y 4 se generan por la relación entre el \texttt{pc} (\texttt{Bot}) y el retorno del método (\texttt{Bot}), y las constraint 5 y 6 se generan por la relación entre la expresión de retorno ($\gamma$ y \texttt{Bot}) y el retorno del método.

\clearpage % TODO

\section{Resolución de constraints de subtyping} \label{propuestaRes}

El siguiente paso del algoritmo de inferencia es la resolución del set de constraints obtenido en la fase de generación de constraints.

El primer paso en la resolución de constraints es la eliminación de constraints \textit{obvias}. Esto es, la eliminación de las constraints \texttt{Bot <: X} y \texttt{X <: Top}, ya que no aportan información útil al algoritmo de inferencia.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Simplificación de constraints}
  \label{pseudosimplify}
    \begin{algorithmic}[1]
      \Function{Simplify}{\texttt{cs}}
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.left \textbf{is} Bot}}
              \State \texttt{cs.remove(constraint)}
            \ElsIf {\texttt{constraint.right \textbf{is} Top}}
              \State \texttt{cs.remove(constraint)}
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
\end{algorithm}

Aplicando el algoritmo \ref{pseudosimplify}, el set de constraints del ejemplo \ref{ej3-1} se reduce a solo dos constraints.

\begin{enumerate}
  \item $\mathtt{\{\alpha <: Obj(eq : [Bot] \rightarrow Bot),\ \beta\}}$
  \item $\mathtt{\{\alpha <: Obj(hash : [\ ] \rightarrow Bot),\ \gamma\}}$
\end{enumerate}

El siguiente paso es agrupar las constraints sobre la misma variable de tipo, usando las reglas del teorema \ref{teo1}. Aplicando el algoritmo \ref{pseudogroup}, el set de constraints del ejemplo \ref{ej3-1} se reduce a solo una constraint.

\begin{ej}\ \\
  \normalfont
  \label{ej3-2}
  \begin{enumerate}
    \item $\mathtt{\{\alpha <: Meet(Obj(eq : [Bot] \rightarrow Bot),\ Obj(hash : [\ ] \rightarrow Bot))\}}$
  \end{enumerate}
\end{ej}

\clearpage % TODO
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Agrupación de constraints}
  \label{pseudogroup}
    \begin{algorithmic}[1]
      \Function{Group}{\texttt{cs, typeVariables}}
          \State $\mathtt{toRemove\gets \{\}}$
          \For {\texttt{tvar \textbf{in} typeVariables}}
            \State $\mathtt{c_1\gets Constraint(tvar, Meet())}$
            \State $\mathtt{c_2\gets Constraint(Join(), tvar)}$
            \For {\texttt{constraint \textbf{in} cs}}
              \If {$\mathtt{constraint.left == tvar}$}
                \State $\mathtt{c_1.right.insert(constraint.right)}$
                \State $\mathtt{toRemove.insert(constraint)}$
              \EndIf
              \If {$\mathtt{constraint.right == tvar}$}
                \State $\mathtt{c_2.left.insert(constraint.left)}$
                \State $\mathtt{toRemove.insert(constraint)}$
              \EndIf
            \EndFor
            \If {$\mathtt{c_1.right.notEmpty()}$}
              \State $\mathtt{cs.insert(c_1)}$
            \EndIf
            \If {$\mathtt{c_2.left.notEmpty()}$}
              \State $\mathtt{cs.insert(c_2)}$
            \EndIf
          \EndFor
          \State $\mathtt{cs.removeAll(toRemove)}$
      \EndFunction
    \end{algorithmic}
\end{algorithm}


\subsection{Unificación}
En este paso, se materializan las operaciones \texttt{meet} y \texttt{join}, se comprueba la validez de las constraints y se realizan substituciones, de forma iterativa.

\subsubsection{Meet y Join}
Cuando se tiene un tipo $\mathtt{Meet(\overline{\tau}})$ o $\mathtt{Join(\overline{\tau}})$, donde $\tau$ no tiene variables de tipo, entonces se puede materializar la operación sobre la lattice correspondiente. Este procedimiento se muestra en el algoritmo \ref{pseudoperations}.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Materialización de operaciones}
  \label{pseudoperations}
    \begin{algorithmic}[1]
      \Function{performOperations}{\texttt{cs}}
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.right \textbf{is} Meet \textbf{and} constraint.right.isConcrete()}}
              \State $\mathtt{constraint.right\gets meet(constraint.right)}$
            \EndIf
            \If {\texttt{constraint.left \textbf{is} Join \textbf{and} constraint.left.isConcrete()}}
              \State $\mathtt{constraint.left\gets join(constraint.left)}$
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
\end{algorithm}

Si aplicamos el algoritmo \ref{pseudoperations} al ejemplo \ref{ej3-2}, se materializa la operación de la constraint.

\begin{enumerate}
  \item $\mathtt{\{\alpha <: Obj(eq : [Bot] \rightarrow Bot, hash : [\ ] \rightarrow Bot)\}}$
\end{enumerate}

\subsubsection{Verificación de constraints}
Cuando una constraint representa una relación no válida, existen dos posibilidades:

\begin{enumerate}
  \item Si la constraint no proviene de una invocación a método, se debe reportar un error.
  \item En caso contrario, se debe reemplazar, en el set de constraints, toda aparición de la faceta de expresión de la constraint, por \texttt{Top}. En este caso no se debe reportar error.
\end{enumerate}

En el ejemplo \ref{gen1}, la constraint 3 proviene de invocación a método y representa una relación de subtyping no válida. Luego, se debe reemplazar la variable de tipo $\gamma$ por \texttt{Top}:

\begin{enumerate}
  \item $\text{Top} <: \alpha$
  \item $\beta <: \text{Bot}$
  \item $\text{Top} <: \text{Obj}(\text{==: }\text{Bot} \rightarrow \text{Bot}), \gamma$
\end{enumerate}

En cambio, en el ejemplo \ref{gen2} simplificado, la constraint \texttt{Top <: Bot} representa una relación no válida que no proviene de invocación a método, por lo que un error debe ser reportado.

La figura 3.4 muestra el algoritmo de verificación de constraints. El método \texttt{substitueXForY(x,y)} busca \texttt{x} en todo el set de constraints, y lo substituye por \texttt{y}.

\begin{figure}[ht]
  \centering
  \label{pseudocheck}
  \begin{mdframed}
    \begin{algorithmic}
      \Function{checkConstraints}{cs}
          \For {c in cs}
            \If {c.isNotValid() and c.isFromMethodInvocation}
              \State cs.substituteXForY(c.expressionType, Top)
            \EndIf
            \If {c.isNotValid() and !c.isFromMethodInvocation}
              \State add SubtypingError
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
  \end{mdframed}
  \caption{Algoritmo de verificación de constraints}
\end{figure}


\subsubsection{Substitución}
Cuando se tiene una constraint que relaciona una variable de tipo y un tipo concreto (sin variables de tipo), se debe substituir en el set de constraint toda aparición de la variable de tipo, por el tipo concreto. Como este proceso puede generar nuevas constraints que sean candidatas a materialización de operaciones, a comprobación o a substitución, se debe iterar hasta que no queden constrainst candidatas.

La figura 3.5 muestra el algoritmo de substitución, mientras que la figura 3.6 muestra el algoritmo de unificación.

\begin{figure}[ht]
  \centering
  \label{pseudosubst}
  \begin{mdframed}
    \begin{algorithmic}
      \Function{performSubstitutions}{cs}
          \For {c in cs}
            \If {c.right.isConcrete() and c.left.isVariable()}
              \State cs.substituteXForY(c.left, c.right)
            \EndIf
            \If {c.left.isConcrete() and c.right.isVariable()}
              \State cs.substituteXForY(c.right, c.left)
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
  \end{mdframed}
  \caption{Algoritmo de substitución}
\end{figure}


\begin{figure}[ht]
  \centering
  \label{pseudouni}
  \begin{mdframed}
    \begin{algorithmic}
      \Function{Unify}{cs}
          \While {cs.hasOperationCandidates or cs.hasSubstCandidates}
            \State performOperations(cs)
            \State checkConstraints(cs)
            \State performSubstitutions(cs)
          \EndWhile
      \EndFunction
    \end{algorithmic}
  \end{mdframed}
  \caption{Algoritmo de unificación}
\end{figure}

Al terminar el algoritmo, cada variable de tipo debe estar asociada a un tipo concreto. El caso de que queden variables de tipo sin resolver puede significar dos cosas:

\begin{itemize}
  \item Falta información para determinar el tipo concreto de una expresión
  \item Cualquier faceta sirve para validar la expresión según las reglas del sistema de tipos
\end{itemize}

Si se informa al usuario un error debido a la ocurrencia del primer caso, esto obliga la anotación de facetas que no son importantes, por lo que se considera al segundo caso una mejor opción.
