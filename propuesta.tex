\chapter{Propuesta}

En este trabajo se propone realizar la implementación de un sistema de inferencia de facetas públicas, que incluya el análisis de \textit{Type-based declassification}, mediante la realización de un plugin para entornos de desarrollo integrado (IDE). En este capítulo se detalla el problema de inferencia a resolver y las estrategias utilizadas para resolverlo.

\section{Problema de inferencia}
Para la formulación del problema, es posible asumir que la información de las facetas privadas de type-based declassification se encuentra a disposición, debido a que algunos lenguajes de programación poseen herramientas para obtener dicha información.

\begin{defn}[Problema de inferencia]
  Dado un programa parcialmente tipado con facetas públicas, y completamente tipado con facetas privadas, encontrar la faceta pública de las expresiones no tipadas que más se ajuste al uso de las expresiones, tal que se cumplan las reglas del sistema de tipos de type-based declassification.
\end{defn}

A continuación, se muestran algunos ejemplos de código parcialmente anotado con facetas públicas, con el objetivo de ilustrar la solución esperada al problema de inferencia.

\begin{ej} \ \\
  \label{ej-tmh}
  \normalfont
\begin{lstlisting}
  bool login(String<Top password, String<String guess) {
    return password.eq(guess);
  }
\end{lstlisting}
\end{ej}

Recordemos que la regla \texttt{TmH} de type-based declassification indica que la invocación a un método no autorizado sobre el objetivo de la llamada, retorna \texttt{Top}. Esto es justamente lo que se quiere inferir para el tipo de retorno del método \texttt{login} en el ejemplo \ref{ej-tmh}.

\begin{ej} \ \\
  \label{ej-tmd}
  \normalfont
\begin{lstlisting}
  bool login(String password, String guess) {
    return password.hash().eq(guess);
  }
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej-tmd} ocurrió un encadenamiento de invocaciones a métodos sobre \texttt{password}. La faceta pública que se quiere inferir para \texttt{password} contiene al método \texttt{hash}, al cual se le quiere inferir una faceta pública de retorno que contiene al método \texttt{eq}. Si se declara una faceta pública de retorno para el método \texttt{eq}, entonces se debe inferir esa misma faceta para el retorno del método \texttt{login}, por la aplicación de la regla \texttt{TmD} de type-based declassification.

\begin{ej} \ \\
  \label{ej-error}
  \normalfont
\begin{lstlisting}
  void check(String<Bot s);

  bool<Top login(String<Top password, String guess) {
    check(password);
    return password.eq(guess);
  }
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej-error}, se debe reportar un error de flujo en el llamado a la función \texttt{check}, debido a que la faceta del argumento debe ser subtipo de la faceta del parámetro, esto es, \texttt{Top <: Bot} es una relación no válida.

\section{Decisiones de diseño}
Para resolver el problema de inferencia, se decidió realizar la implementación de un algoritmo de inferencia basado en constraints de subtyping. Como el objetivo de este trabajo no es formalizar un sistema de inferencia para type-based declassification, se implementa un algoritmo heurístico reutilizando enfoques e ideas de trabajos con características similares, lo cual fue presentado en la sección \ref{inference}.

El subconjunto del lenguaje orientado objetos a considerar tendrá clases, métodos, variables, asignaciones e instrucciones condicionales.

Con respecto al control de flujo, como el subconjunto a considerar tendrá instrucciones condicionales, se deben detectar flujos implícitos para preservar relaxed noninterference, por lo que se utilizará el concepto de \texttt{pc} presentado en la sección \ref{controlflujo}.

Debido a que la implementación se realizará en un lenguaje orientado a objetos de propósito general, se debe tomar una decisión acerca de las facetas públicas de los métodos que pertenecen al \emph{core} del lenguaje, ya que no pueden ser anotados. Para ilustrar la necesidad de discutir esta decisión, veamos el siguiente ejemplo:

\begin{ej} \ \\
  \label{ej-necesidad}
  \normalfont
\begin{lstlisting}
  int<Bot getLength(String password) {
    return password.length
  }
\end{lstlisting}
\end{ej}



Este método será aceptado o rechazado por las reglas del sistema de tipos, si la faceta pública de retorno del campo \texttt{length} es \texttt{Bot} o \texttt{Top} respectivamente.

Si decidimos que la faceta pública de retorno para métodos del core del lenguaje es \texttt{Top}, entonces cualquier operación que realicemos sobre el valor de retorno, retornará \texttt{Top}, lo cual es poco útil. Por lo tanto la decisión por defecto es que la faceta pública de retorno para métodos del core del lenguaje sea \texttt{Bot}.

Ahora, analicemos ambas posibilidades para la faceta pública por defecto de los parámetros:

\begin{itemize}
  \item \texttt{Top} $\rightarrow$ \texttt{Bot}: Supongamos que el core del lenguaje posee un método \texttt{identity}, que dado un \texttt{x}, retorna \texttt{x}. Si tomamos esta decisión, entonces el método \texttt{identity} podrá ser usado como desclasificador universal, como por ejemplo \texttt{identity(password)}.
  \item \texttt{Bot} $\rightarrow$ \texttt{Bot}: Esta elección restringe las facetas públicas de los argumentos utilizados a \texttt{Bot}, lo cual también podría ser considerado poco útil. Sin embargo, al retornar un valor con faceta pública \texttt{Bot}, cualquier operación podrá ser utilizada sobre ese valor.
\end{itemize}

Haciendo un balance, se considera que la opción \texttt{Bot} $\rightarrow$ \texttt{Bot} tiene el mejor equilibrio entre utilidad y seguridad, por lo que es la opción por defecto considerada. Sin embargo, es deseable que la herramienta se pueda configurar para elegir otra alternativa.

\section{Gramática de tipos}
Por lo discutido en la sección \ref{inference}, es necesario introducir variables de tipo para presentar un algoritmo de inferencia basado en constraints. Además, se deben definir los otros tipos que serán utilizados internamente en el análisis. Esto se hace definiendo la gramática de tipos que usará el sistema de inferencia:

  $\mathtt{\tau := \alpha\ |\ Obj(\overline{l: \tau})\ |\ [\overline{\tau}] \rightarrow \tau \ |\ Join(\overline{\tau})\ |\ Meet(\overline{\tau})\ |\ Bot\ |\ Top}$

Donde $\alpha$ es cualquier variable de tipo, $\mathtt{Obj(\overline{l: \tau}})$ representa el tipo de un objeto y $\mathtt{l}$ es un nombre de método. Notar que aquí se reutilizó la idea de los tipos \texttt{meet} y \texttt{join} que propuso Cardelli~\cite{cardelli}.

\section{Generación de constraints de subtyping} \label{propuestaGen}
Como se mencionó en la sección \ref{inference}, el uso de constraints permite presentar un algoritmo de inferencia como una fase de generación de constraints, y una fase de resolución de constraints.

El algoritmo de generación de constraints se ejecuta en cada nodo del árbol de sintaxis abstracta (AST). A continuación se explicarán las reglas de generación de constraints, y luego se mostrará el algoritmo en pseudolenguaje.

\paragraph{Invocación a método.}Cuando se procesa un nodo que representa una invocación a método, se genera una constraint entre el objetivo de la invocación, y un tipo de objeto que contiene al método invocado. Esta constraint almacena el tipo de expresión de la invocación, debido a la posible aplicación de la regla \texttt{TmH} de type-based declassification, lo cual se explica en la sección \ref{propuestaVer}. Además, por cada argumento de la invocación, se genera una constraint entre el argumento y el parámetro correspondiente de la declaración del método.

\paragraph{Expresión de retorno.}Cuando se procesa un nodo que representa una expresión de retorno, se genera una constraint entre la expresión de retorno y el retorno declarado por el método. Además, se genera una constraint entre el \texttt{pc} y el retorno declarado del método, debido a que la expresión de retorno puede ocurrir dentro del cuerpo de un condicional.

\paragraph{Expresión de asignación.}Cuando se procesa un nodo que representa una expresión de asignación, se genera una constraint entre el lado derecho de la asignación y el lado izquierdo de la asignación. Además, se genera una constraint entre el \texttt{pc} y el lado izquierdo de la asignación, por el mismo motivo que en la expresión de retorno.

\paragraph{Expresión condicional.}Cuando se procesa un nodo que representa una expresión condicional (como \texttt{if} y \texttt{while}), se cambia el \texttt{pc} por la faceta pública de la condición, debido a que será utilizado por el algoritmo en el cuerpo del condicional.

El algoritmo \ref{pseudogen} muestra la generación de constraints para un nodo determinado del AST. Ejecutando la función del algoritmo \ref{pseudogen} en todos los nodos del AST y uniendo los resultados, se obtiene el set de constraints.
\clearpage

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Generación de constraints}
  \label{pseudogen}
    \begin{algorithmic}[1]
      \Function{Constraint\_Generation}{\texttt{node, pc}}
          \State $\mathtt{cs\gets \{\}}$
          \Switch{\texttt{node}}
            \Case{\texttt{MethodInvocation(name, target, signature, expression, arguments)}}
              \State \texttt{cs.insert(target <: Obj(name: signature), expression)}
              \For {$\mathtt{argument,correspondingParameter\ \mathbf{in}\ arguments}$}
                \State \texttt{cs.insert(argument <: correspondingParameter})
              \EndFor
            \EndCase
            \Case{\texttt{ReturnStatement(expression, methodReturn)}}
              \State \texttt{cs.insert(expression <: methodReturn)}
              \State \texttt{cs.insert(pc <: methodReturn)}
            \EndCase
            \Case{\texttt{AssignmentExpression(leftHand, rightHand)}}
              \State \texttt{cs.insert(rightHand <: LeftHand)}
              \State \texttt{cs.insert(pc <: LeftHand)}
            \EndCase
            \Case{\texttt{IfExpression(conditionExpression)}}
              \State $\mathtt{pc\gets conditionExpression}$
            \EndCase
          \EndSwitch
          \State \Return \texttt{cs, pc}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
A modo de ejemplo, consideremos el siguiente código parcialmente anotado con facetas públicas, y las constraints que se generan



\begin{ej}\ \\
  \label{ej3-1}
  \normalfont
  \begin{lstlisting}
  String<String login(String<String guess, String password) {
    if (password.eq(guess)) return password.hash();
    else return "Login failed.";
  }
  \end{lstlisting}
  \begin{enumerate}
    \item $\mathtt{\{\alpha <: Obj(eq : [Bot] \rightarrow Bot),\ \beta\}}$
    \item $\mathtt{\{\alpha <: Obj(hash : [\ ] \rightarrow Bot),\ \gamma\}}$
    \item $\mathtt{\{Bot <: Bot\}}$
    \item $\mathtt{\{Bot <: Bot\}}$
    \item $\mathtt{\{\gamma <: Bot\}}$
    \item $\mathtt{\{Bot <: Bot\}}$
  \end{enumerate}
\end{ej}


Las constraints 1 y 2 se generan por las llamadas a métodos sobre el parámetro \texttt{password}, que fue asignado con una variable de tipo $\alpha$. Las constraints 3 y 4 se generan por la relación entre el \texttt{pc} (\texttt{Bot}) y el retorno del método (\texttt{Bot}), y las constraint 5 y 6 se generan por la relación entre la expresión de retorno ($\gamma$ y \texttt{Bot}) y el retorno del método.

Además de la generación de constraints, en este paso se realiza la verificación de well-formed en las expresiones que tienen facetas públicas declaradas. Esto se muestra en el algoritmo \ref{wellformed}, para un nodo determinado del AST.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Verificación de well-formed}
  \label{wellformed}
    \begin{algorithmic}[1]
      \Function{isWellFormed}{\texttt{node}}
          \If {$\mathtt{node.hasDeclaredPublicFacet()}$}
            \State \Return \texttt{node.privateFacet.subtypeOf(node.publicFacet)}
          \EndIf
          \State \Return \texttt{true}
      \EndFunction
    \end{algorithmic}
\end{algorithm}

\section{Resolución de constraints de subtyping} \label{propuestaRes}

El primer paso en la resolución de constraints es la eliminación de constraints \textit{obvias}. Esto es, la eliminación de las constraints \texttt{Bot <: X} y \texttt{X <: Top}, ya que no aportan información útil al algoritmo de inferencia.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Simplificación de constraints}
  \label{pseudosimplify}
    \begin{algorithmic}[1]
      \Function{Simplify}{\texttt{cs}}
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.left \textbf{is} Bot}}
              \State \texttt{cs.remove(constraint)}
            \ElsIf {\texttt{constraint.right \textbf{is} Top}}
              \State \texttt{cs.remove(constraint)}
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
\end{algorithm}

Aplicando el algoritmo \ref{pseudosimplify}, el set de constraints del ejemplo \ref{ej3-1} se reduce a solo tres constraints.

\begin{enumerate}
  \item $\mathtt{\{\alpha <: Obj(eq : [Bot] \rightarrow Bot),\ \beta\}}$
  \item $\mathtt{\{\alpha <: Obj(hash : [\ ] \rightarrow Bot),\ \gamma\}}$
  \item $\mathtt{\{\gamma <: Bot\}}$
\end{enumerate}

El siguiente paso es agrupar las constraints sobre la misma variable de tipo, usando las reglas del teorema \ref{teo1}. Aplicando el algoritmo \ref{pseudogroup}, el set de constraints del ejemplo \ref{ej3-1} se reduce a solo dos constraints.

\begin{ej}\ \\
  \normalfont
  \label{ej3-2}
  \begin{enumerate}
    \item $\mathtt{\{\alpha <: Meet(Obj(eq : [Bot] \rightarrow Bot),\ Obj(hash : [\ ] \rightarrow Bot))\}}$
    \item $\mathtt{\{\gamma <: Bot\}}$
  \end{enumerate}
\end{ej}

\clearpage % TODO
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Agrupación de constraints}
  \label{pseudogroup}
    \begin{algorithmic}[1]
      \Function{Group}{\texttt{cs, typeVariables}}
          \State $\mathtt{toRemove\gets \{\}}$
          \For {\texttt{tvar \textbf{in} typeVariables}}
            \State $\mathtt{c_1\gets Constraint(tvar, Meet())}$
            \State $\mathtt{c_2\gets Constraint(Join(), tvar)}$
            \For {\texttt{constraint \textbf{in} cs}}
              \If {$\mathtt{constraint.left == tvar}$}
                \State $\mathtt{c_1.right.insert(constraint.right)}$
                \State $\mathtt{toRemove.insert(constraint)}$
              \EndIf
              \If {$\mathtt{constraint.right == tvar}$}
                \State $\mathtt{c_2.left.insert(constraint.left)}$
                \State $\mathtt{toRemove.insert(constraint)}$
              \EndIf
            \EndFor
            \If {$\mathtt{c_1.right.notEmpty()}$}
              \State $\mathtt{cs.insert(c_1)}$
            \EndIf
            \If {$\mathtt{c_2.left.notEmpty()}$}
              \State $\mathtt{cs.insert(c_2)}$
            \EndIf
          \EndFor
          \State $\mathtt{cs.removeAll(toRemove)}$
      \EndFunction
    \end{algorithmic}
\end{algorithm}


\subsection{Unificación}
En este paso, se materializan las operaciones \texttt{meet} y \texttt{join}, se comprueba la validez de las constraints y se realizan substituciones de forma iterativa.

\subsubsection{Meet y Join}
Cuando se tiene un tipo $\mathtt{Meet(\overline{\tau}})$ o $\mathtt{Join(\overline{\tau}})$, donde $\tau$ no tiene variables de tipo, entonces se puede materializar la operación sobre la lattice correspondiente. Este procedimiento se muestra en el algoritmo \ref{pseudoperations}. La operación \texttt{meet} consiste en la unión de los miembros de cada tipo de objeto en el tipo \texttt{Meet}, y \texttt{join} consiste en la intersección de los miembros de cada tipo de objeto en el tipo \texttt{Join}.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Materialización de operaciones}
  \label{pseudoperations}
    \begin{algorithmic}[1]
      \Function{performOperations}{\texttt{cs}}
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.right \textbf{is} Meet \textbf{and} constraint.right.isConcrete()}}
              \State $\mathtt{constraint.right\gets}$
              \State \ \ \ \ \ \ \ \ \ $\mathtt{constraint.right.reduce((t1,t2) => Obj(t1.members \cup t2.members))}$
            \EndIf
            \If {\texttt{constraint.left \textbf{is} Join \textbf{and} constraint.left.isConcrete()}}
              \State $\mathtt{constraint.left\gets}$
              \State \ \ \ \ \ \ \ \ \ $\mathtt{constraint.left.reduce((t1,t2) => Obj(t1.members \cap t2.members))}$
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
\end{algorithm}

Si aplicamos el algoritmo \ref{pseudoperations} al ejemplo \ref{ej3-2}, se materializa la operación de la constraint 1.

\begin{enumerate}
  \item $\mathtt{\{\alpha <: Obj(eq : [Bot] \rightarrow Bot, hash : [\ ] \rightarrow Bot)\}}$
  \item $\mathtt{\{\gamma <: Bot\}}$
\end{enumerate}

\subsubsection{Verificación de constraints} \label{propuestaVer}
Cuando una constraint representa una relación no válida, existen dos casos posibles:

\begin{enumerate}
  \item Si la constraint no proviene de una invocación a método, se debe reportar un error.
  \item En caso contrario, se debe reemplazar por \texttt{Top} toda aparición del tipo de expresión de la constraint, en el set de constraints. En este caso no se debe reportar error.
\end{enumerate}

En el ejemplo \ref{ej-tmh}, las constraints relevantes generadas son:

\begin{enumerate}
  \item $\{\mathtt{Top <: Obj(eq: Bot \rightarrow Bot),\ \alpha}\}$
  \item $\{\mathtt{\alpha <: \beta}\}$
\end{enumerate}

Donde $\beta$ es la faceta pública de retorno de \texttt{login}. Como la constraint 1 representa una relación no válida y proviene de invocación a método, el tipo de expresión $\alpha$ debe substituirse por \texttt{Top} en el set de constraint. Luego, la constraint 2 cambia a $\{\mathtt{Top <: \beta}\}$.

El algoritmo \ref{pseudocheck} muestra la verificación de constraints. Este algoritmo usa la función \texttt{substitute}, que se muestra en el algoritmo \ref{pseudosubstitute}.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Verificación de constraints}
  \label{pseudocheck}
    \begin{algorithmic}[1]
      \Function{checkConstraints}{\texttt{cs,errorCollector}}
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.isNotValid() \textbf{and} constraint.isFromMethodInvocation()}}
              \For {\texttt{c \textbf{in} cs}}
                \State $\mathtt{c.left\gets substitute(c.left,\ constraint.expressionType,\ Top)}$
                \State $\mathtt{c.right\gets substitute(c.right,\ constraint.expressionType,\ Top)}$
              \EndFor
            \ElsIf {\texttt{constraint.isNotValid()}}
              \State \texttt{errorCollector.insert(SubtypingError)}
            \EndIf
          \EndFor
      \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Substitución dentro de tipos}
  \label{pseudosubstitute}
    \begin{algorithmic}[1]
      \Function{substitute}{\texttt{source,target,newType}}
          \If {\texttt{source == target}}
            \State \Return \texttt{newType}
          \EndIf
          \Switch{\texttt{source}}
            \Case{\texttt{Obj(members)}}
              \State \Return \texttt{Obj(members.map((l,s) => {l: substitute(s,target,newType)}))}
            \EndCase
            \Case{$\mathtt{x \rightarrow y}$}
              \State \Return $\mathtt{substitute(x,target,newType)\rightarrow substitute(y,target,newType)}$
            \EndCase
            \Case{\texttt{Meet(types)}}
              \State \Return \texttt{Meet(Meet.map((t) => substitute(t,target,newType))}
            \EndCase
            \Case{\texttt{Join(types)}}
              \State \Return \texttt{Join(Join.map((t) => substitute(t,target,newType)))}
            \EndCase
            \Case{\texttt{Bot}}
              \State \Return \texttt{Bot}
            \EndCase
            \Case{\texttt{Top}}
              \State \Return \texttt{Top}
            \EndCase
            \Case{$\alpha$}
              \State \Return $\alpha$
            \EndCase
          \EndSwitch
      \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsubsection{Substitución}
Cuando se tiene una constraint que relaciona una variable de tipo con un tipo concreto\footnote{Un tipo concreto no tiene variables de tipo}, se debe substituir en el set de constraint toda aparición de la variable de tipo, por el tipo concreto. Como este proceso puede generar nuevas constraints que sean candidatas a materialización de operaciones, a verificación o a substitución, se debe iterar hasta que no queden constrainst candidatas. El algoritmo \ref{pseudosubst} muestra la substitución de constraints resueltas, mientras que el algoritmo \ref{pseudouni} muestra el procedimiento completo de unificación.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Substitución de constraints}
  \label{pseudosubst}
    \begin{algorithmic}[1]
      \Function{substituteResolved}{\texttt{cs}}
          \State $\mathtt{m\gets \{\}}$
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.right.isConcrete() \textbf{and} constraint.left.isVariable()}}
              \For {\texttt{c \textbf{in} cs, c != constraint}}
                \State $\mathtt{c.left\gets substitute(c.left,\ constraint.left,\ constraint.right)}$
                \State $\mathtt{c.right\gets substitute(c.right,\ constraint.left,\ constraint.right)}$
              \EndFor
              \State $\mathtt{m[constraint.left]\gets constraint.right}$
              \State \texttt{cs.remove(constraint)}
            \EndIf
            \If {\texttt{constraint.left.isConcrete() \textbf{and} constraint.right.isVariable()}}
              \For {\texttt{c \textbf{in} cs, c != constraint}}
                \State $\mathtt{c.left\gets substitute(c.left,\ constraint.right,\ constraint.left)}$
                \State $\mathtt{c.right\gets substitute(c.right,\ constraint.right,\ constraint.left)}$
              \EndFor
              \State $\mathtt{m[constraint.right]\gets constraint.left}$
              \State \texttt{cs.remove(constraint)}
            \EndIf
          \EndFor
          \State \Return \texttt{m}
      \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Unificación}
  \label{pseudouni}
    \begin{algorithmic}[1]
      \Function{Unify}{\texttt{cs,errorCollector}}
          \State $\mathtt{m\gets \{\}}$
          \While {\texttt{cs.hasOperationCandidates() \textbf{or} cs.hasSubstCandidates()}}
            \State \texttt{performOperations(cs)}
            \State \texttt{checkConstraints(cs, errorCollector)}
            \State \texttt{m.addAll(substitueResolved(cs))}
          \EndWhile
          \State \Return \texttt{m}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
\clearpage
La función de unificación retorna un mapeo entre cada variable de tipo y un tipo concreto. El caso de que queden variables de tipo sin resolver puede significar dos cosas:

\begin{itemize}
  \item Falta información para determinar el tipo concreto de una expresión, lo que no significa errores de tipos
  \item Cualquier faceta sirve para validar la expresión según las reglas del sistema de tipos
\end{itemize}

Si se informa al usuario un error debido a la ocurrencia del primer caso, esto obliga la anotación de facetas que no son importantes, por lo que se considera al segundo caso una mejor opción.
