\chapter{Inferencia de facetas públicas en Dart}

En este trabajo se propone realizar la implementación de un sistema de inferencia de facetas públicas en el lenguaje Dart, que incluya el análisis de la desclasificación basada en tipos, y luego la realización de una extensión para ambientes de desarrollo. En este capítulo se detalla el problema de inferencia a resolver y las estrategias utilizadas para resolverlo.

\section{Problema de inferencia de facetas públicas}
Para la formulación del problema, es posible asumir que la información de las facetas privadas de la desclasificación basada en tipos se encuentra a disposición, debido a que se pueden convertir los tipos estáticos comunes (como \texttt{String}) de Dart en facetas privadas. Los detalles de esta conversión se explican en la sección \ref{conv}.

\begin{defn}[Problema de inferencia]
  Dado un programa parcialmente tipado con facetas públicas, y completamente tipado con facetas privadas, encontrar la faceta pública de las expresiones no tipadas que más se ajuste al uso de las expresiones, tal que el programa sea bien tipado.
\end{defn}

A continuación, se muestran algunos ejemplos de código parcialmente anotado con facetas públicas, con el objetivo de ilustrar la solución esperada al problema de inferencia.

\begin{ej} \ \\
  \label{ej-tmh}
  \normalfont
\begin{lstlisting}
  bool login(String<Top password, String<String guess) {
    return password.eq(guess);
  }
\end{lstlisting}
\end{ej}

Recordemos que la regla $\text{TmH}$ de la desclasificación basada en tipos indica que la invocación a un método no autorizado sobre el receptor de la llamada, retorna \texttt{Top}. Esto es lo que se quiere inferir para el tipo de retorno del método \texttt{login} en el ejemplo \ref{ej-tmh}.

\begin{ej} \ \\
  \label{ej-tmd}
  \normalfont
\begin{lstlisting}
  bool login(String password, String guess) {
    return password.hash().eq(guess);
  }
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej-tmd} ocurrió un encadenamiento de invocaciones a métodos sobre \texttt{password}. La faceta pública que se quiere inferir para \texttt{password} contiene al método \texttt{hash}, al cual se le quiere inferir una faceta pública de retorno que contiene al método \texttt{eq}. Si se declara una faceta pública de retorno para el método \texttt{eq}, entonces se debe inferir esa misma faceta para el retorno del método \texttt{login}, por la aplicación de la regla $\text{TmD}$ de la desclasificación basada en tipos.

\section{Perspectiva general de la solución} \label{diseno}
Para resolver el problema de inferencia, se decidió realizar la implementación de un algoritmo de inferencia global basado en restricciones sobre subtipos, con tipos estructurales. Como el objetivo de este trabajo no es formalizar un sistema de inferencia para la desclasificación basada en tipos, se implementa un algoritmo heurístico reutilizando enfoques e ideas de trabajos con características similares, lo cual fue presentado en el capítulo \ref{inference}. La propuesta de solución se divide en los siguientes pasos:

\begin{enumerate}
  \item Definición de los tipos utilizados por el sistema de inferencia mediante la gramática de tipos.
  \item Integración de los tipos estáticos comunes de Dart con las facetas de la desclasificación basada en tipos.
  \item Descripción del paso de generación de restricciones para un programa de Dart.
  \item Descripción del paso de resolución de restricciones.
\end{enumerate}

El subconjunto del lenguaje Dart a considerar en la implementación tendrá clases, métodos, variables, asignaciones e instrucciones condicionales.

Con respecto al control de flujo de información, como el subconjunto del lenguaje a considerar tiene instrucciones condicionales, se deben detectar flujos implícitos para preservar la propiedad de no-interferencia relajada, por lo que se utiliza el concepto de contexto de seguridad presentado en el capítulo \ref{controlflujo}.
\clearpage
\section{Gramática de tipos}
Por lo discutido en el capítulo \ref{inference}, es necesario introducir variables de tipo para presentar un algoritmo de inferencia basado en restricciones. Además, se incluyen los constructores $\sqcap$ y $\sqcup$ que representan las operaciones \texttt{meet} y \texttt{join} sobre un orden parcial, y se definen los otros tipos que serán utilizados en el análisis. Esto se hace definiendo la gramática de tipos que usará el sistema de inferencia:

  \[\mathtt{\tau := \alpha\ |\ Obj(\overline{l: \tau})\ |\ \overline{\tau} \rightarrow \tau \ |\ \tau \sqcap \tau\ |\ \tau \sqcup \tau\ |\ Bot\ |\ Top}\]

Donde $\alpha$ es cualquier variable de tipo. La barra superior indica una lista de elementos. Por ejemplo, $\mathtt{Obj(\overline{l: \tau}})$ representa el tipo de un objeto con una lista de métodos de nombre \texttt{l} y firma $\tau$.

\section{Conversión a facetas privadas} \label{conv}
Para que la implementación del sistema de tipos de la desclasificación basada en tipos se integre con Dart, se debe realizar una conversión de los tipos que son incluidos por defecto en todo programa de Dart (\emph{core} de Dart), como \texttt{String} y \texttt{List}, a facetas privadas de la desclasificación basada en tipos.

Sea $[m_i: \overline{A_i} \rightarrow B_i]$ un tipo de objeto con métodos $m_i$. La operación \texttt{convert} se define como sigue:

\[
\mathtt{convert}([m_i: \overline{A_i} \rightarrow B_i]) = [m_i: \overline{A_i\text{\texttt{<}}P_{Ai}} \rightarrow B_i\text{\texttt{<}}P_{Bi}]
\]

Lo que hace \texttt{convert} es reemplazar el tipo de objeto de Dart por una faceta privada, donde los tipos de los parámetros y retorno de cada método se convierten a tipos de dos facetas, con faceta pública $P_{Ai}$ y $P_{Bi}$ respectivamente.

Las facetas públicas $P_{Ai}$ y $P_{Bi}$ se pueden establecer según distintos criterios. En un sistema de tipos con polimorfismo, podemos considerarlas como variables de tipo cuantificadas, que pueden tomar distintos valores. Aquello está fuera del alcance de este trabajo, por lo que se debe tomar una decisión respecto al valor que tendrán las facetas públicas en la operación \texttt{convert}.

Hay dos opciones para tipar las facetas públicas: \texttt{Top} y \texttt{Bot}, debido a que son las únicas facetas públicas que se conocen de antemano. Primero, veamos las opciones para la faceta pública de retorno $P_{Bi}$. Si decidimos que $P_{Bi}$ es igual a \texttt{Top}, entonces el sistema de inferencia terminará asignando \texttt{Top} a cada expresión que se asocie con un llamado a un método del \emph{core} de Dart, lo cual se propaga rápidamente. Esto es poco útil, debido a que el sistema de inferencia detectará flujos inválidos cuando en la práctica no hay una fuga de información. Por lo tanto, la decisión por defecto es que $P_{Bi}$ sea \texttt{Bot}, es decir, igual a la faceta privada $B_i$.

Ahora, analicemos ambas posibilidades para $P_{Ai}$:

\begin{itemize}
  \item \texttt{Top}: Supongamos que el core del lenguaje posee un método \texttt{identity}, que dado un \texttt{x}, retorna \texttt{x}. Si tomamos esta decisión, entonces el método \texttt{identity} podrá ser usado como desclasificador universal, como por ejemplo \texttt{identity(password)}.
  \item \texttt{Bot}: Esta elección restringe las facetas públicas de los argumentos utilizados a \texttt{Bot}, lo cual también podría ser considerado poco útil. Sin embargo, al retornar un valor con faceta pública \texttt{Bot}, cualquier operación podrá ser utilizada sobre ese valor.
\end{itemize}

Haciendo un balance, se considera que la opción \texttt{Bot} tiene el mejor equilibrio entre utilidad y seguridad, por lo que es la opción por defecto considerada. Con esto, la versión utilizada de \texttt{convert} es:

\[
\mathtt{convert}([m_i: \overline{A_i} \rightarrow B_i]) = [m_i: \overline{A_i\text{\texttt{<}}A_i} \rightarrow B_i\text{\texttt{<}}B_i]
\]

\section{Generación de restricciones sobre subtipos} \label{propuestaGen}
Como se mencionó en la sección \ref{sechm}, el uso de restricciones permite presentar un algoritmo de inferencia como una fase de generación de restricciones, y una fase de resolución de restricciones.

El algoritmo de generación de restricciones es un algoritmo recursivo que se ejecuta sobre un nodo del árbol de sintaxis abstracta (AST) del programa y retorna un tipo y un conjunto de restricciones. A continuación se explican informalmente las reglas de generación de restricciones, y luego se muestra el algoritmo en pseudocódigo.

\paragraph{Invocación a método.}Cuando se procesa un nodo que representa una invocación a método, se genera la restricción \texttt{(target <: Obj(name: signature), exp)}, donde \texttt{target} es el tipo del receptor de la invocación, \texttt{Obj(name: signature)} es un tipo de objeto que contiene al método invocado, y \texttt{exp} es el tipo de la expresión de invocación. El tipo de la expresión se almacena en la restricción debido a la posible aplicación de la regla $\text{TmH}$ de la desclasificación basada en tipos, lo cual se explica en la sección \ref{propuestaVer}. Además, por cada argumento de la invocación, se genera la restricción \texttt{(arg <: par)}, donde \texttt{arg} es el tipo del argumento y \texttt{par} es el tipo del correspondiente parámetro del método.

\paragraph{Expresión de retorno.}Cuando se procesa un nodo que representa una expresión de retorno, se genera la restricción \texttt{(exp <: ret)}, donde \texttt{exp} es el tipo de la expresión de retorno y \texttt{ret} es el tipo de retorno en la firma del método. Además, se genera la restricción \texttt{(pc <: ret)}, donde \texttt{pc} es el contexto de seguridad, debido a que la expresión de retorno puede ocurrir dentro del cuerpo de un condicional.

\paragraph{Expresión de asignación.}Cuando se procesa un nodo que representa una expresión de asignación, se genera la restricción \texttt{(right <: left)}, donde \texttt{right} es el tipo del lado derecho de la asignación y \texttt{left} es el tipo del lado izquierdo de la asignación. Además, se genera la restricción \texttt{(pc <: left)}, por el mismo motivo que en la expresión de retorno.

\paragraph{Expresión condicional.}Cuando se procesa un nodo que representa una expresión condicional (como \texttt{if} y \texttt{while}), se cambia el contexto de seguridad por la faceta pública de la condición, debido a que será utilizado por el algoritmo en el cuerpo del condicional.

El algoritmo \ref{pseudogen} muestra la generación de restricciones para un nodo determinado del AST. Se asume la existencia de un almacén (\emph{store}) que almacena los tipos de los identificadores. En la línea \ref{lineTVar} se asigna una variable de tipo a \texttt{type}. La asignación de la línea \ref{lineAss} asigna el tipo retornado por la función \texttt{Constraint\_Generation} a \texttt{targetType} y el conjunto de restricciones retornado por la misma función a \texttt{targetCS}.

En el ejemplo \ref{ej3-1} se muestra un código parcialmente anotado con facetas públicas. En este ejemplo, se espera inferir una faceta pública para \texttt{password} que contenga a los métodos \texttt{eq} y \texttt{hash}. En esta sección se muestra el conjunto de restricciones generado para el ejemplo \ref{ej3-1}, mientras que en la sección \ref{propuestaRes} se muestra la resolución de este conjunto.

\begin{ej}\ \\
  \label{ej3-1}
  \normalfont
  \begin{lstlisting}
  String<String login(String<String guess, String password) {
    if (password.eq(guess)) return password.hash();
    else return "Login failed.";
  }
  \end{lstlisting}
  \begin{enumerate}
    \item $\mathtt{(\alpha <: Obj(eq : [Bot] \rightarrow Bot),\ \beta)}$
    \item $\mathtt{(\alpha <: Obj(hash : [\ ] \rightarrow Bot),\ \gamma)}$
    \item $\mathtt{(Bot <: Bot)}$
    \item $\mathtt{(Bot <: Bot)}$
    \item $\mathtt{(\gamma <: Bot)}$
    \item $\mathtt{(Bot <: Bot)}$
  \end{enumerate}
\end{ej}

La variable de tipo $\alpha$ corresponde al tipo del parámetro \texttt{password}. La variable de tipo $\beta$ corresponde al tipo de la condición en la expresión condicional. La variable de tipo $\gamma$ corresponde al tipo de la expresión de la invocación a método \texttt{password.hash()}.

Las restricciones 1 y 2 se generan por las llamadas a métodos sobre el parámetro \texttt{password}. Las restricciones 3 y 4 se generan por la relación entre el contexto de seguridad (\texttt{Bot}) y el retorno del método (\texttt{Bot}) en ambas ramas de la expresión condicional, y las restricciones 5 y 6 se generan por la relación entre la expresión de retorno ($\gamma$ y \texttt{Bot}) y el retorno del método en ambas ramas de la expresión condicional.
\clearpage
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Generación de restricciones. La entrada \texttt{node} es un nodo del AST, y \texttt{pc} es el contexto de seguridad. La salida es una dupla con el tipo de la expresión representada por \texttt{node} y el conjunto de restricciones generado.}
  \label{pseudogen}
    \begin{algorithmic}[1]
      \Function{Constraint\_Generation}{\texttt{node, pc}}
          \State $\mathtt{cs\gets \{)}$
          \State $\mathtt{type\gets Bot}$
          \Switch{\texttt{node}}
            \Case{\texttt{Identifier(name)}}
              \State $\mathtt{type\gets Store.getType(name)}$
            \EndCase
            \Case{\texttt{MethodInvocation(name, target, signature, arguments)}}
              \State $\mathtt{type\gets \alpha}$ \label{lineTVar}
              \State $\mathtt{targetType, targetCS\gets Constraint\_Generation(target, pc)}$ \label{lineAss}
              \State \texttt{cs.insert(targetType <: Obj(name: signature), type)}
              \State \texttt{cs.addAll(targetCS)}
              \For {$\mathtt{argument,parType\ \mathbf{in}\ arguments}$}
                \State $\mathtt{argType, argCS\gets Constraint\_Generation(argument, pc)}$
                \State \texttt{cs.insert(argType <: parType})
                \State \texttt{cs.addAll(argCS)}
              \EndFor
            \EndCase
            \Case{\texttt{ReturnStatement(expression, methodReturn)}}
              \State $\mathtt{expType, expCS\gets Constraint\_Generation(expression, pc)}$
              \State \texttt{cs.insert(expType <: methodReturn)}
              \State \texttt{cs.insert(pc <: methodReturn)}
              \State \texttt{cs.addAll(expCS)}
            \EndCase
            \Case{\texttt{AssignmentExpression(leftHand, rightHand)}}
              \State $\mathtt{leftType, leftCS\gets Constraint\_Generation(leftHand, pc)}$
              \State $\mathtt{rightType, rightCS\gets Constraint\_Generation(rightHand, pc)}$
              \State \texttt{cs.insert(rightType <: leftType)}
              \State \texttt{cs.insert(pc <: leftType)}
              \State \texttt{cs.addAll(leftCS, rightCS)}
            \EndCase
            \Case{\texttt{IfExpression(conditionExpression, thenExpression, elseExpression)}}
              \State $\mathtt{condType, condCS\gets Constraint\_Generation(conditionExpression, pc)}$
              \State $\mathtt{thenType, thenCS\gets Constraint\_Generation(thenExpression, condType)}$
              \State $\mathtt{elseType, elseCS\gets Constraint\_Generation(elseExpression, condType)}$
              \State \texttt{cs.addAll(condCS, thenCS, elseCS)}
            \EndCase
          \EndSwitch
          \State \Return \texttt{type, cs}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
\clearpage

Además de la generación de restricciones, en este paso se verifica que las expresiones que tienen facetas públicas declaradas cumplan con la restricción de tipos bien formados. Esto se muestra en el algoritmo \ref{wellformed}, para un nodo determinado del AST.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Verificación de tipos bien formados. La entrada \texttt{node} es un nodo del AST y la salida es un valor booleano.}
  \label{wellformed}
    \begin{algorithmic}[1]
      \Function{isWellFormed}{\texttt{node}}
          \If {$\mathtt{node.hasDeclaredPublicFacet()}$}
            \State \Return \texttt{node.privateFacet.subtypeOf(node.publicFacet)}
          \EndIf
          \State \Return \texttt{true}
      \EndFunction
    \end{algorithmic}
\end{algorithm}

\section{Resolución de restricciones sobre subtipos} \label{propuestaRes}

El primer paso en la resolución de restricciones es la eliminación de restricciones \textit{obvias}. Esto es, la eliminación de las restricciones \texttt{(Bot <: X)} y \texttt{(X <: Top)}, ya que no aportan información útil al algoritmo de inferencia.

\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Simplificación de restricciones. La entrada es un conjunto de restricciones. La salida es un conjunto de restricciones simplificado.}
  \label{pseudosimplify}
    \begin{algorithmic}[1]
      \Function{Simplify}{\texttt{cs}}
          \State $\mathtt{newCs\gets cs}$
          \For {\texttt{constraint \textbf{in} newCs}}
            \If {\texttt{constraint.left \textbf{is} Bot}}
              \State \texttt{newCs.remove(constraint)}
            \ElsIf {\texttt{constraint.right \textbf{is} Top}}
              \State \texttt{newCs.remove(constraint)}
            \EndIf
          \EndFor
          \State \Return \texttt{newCs}
      \EndFunction
    \end{algorithmic}
\end{algorithm}

Aplicando el algoritmo \ref{pseudosimplify}, el conjunto de restricciones del ejemplo \ref{ej3-1} se reduce a solo tres restricciones, lo que se muestra en el ejemplo \ref{ejsimplify}.

\begin{ej}\
  \normalfont
  \label{ejsimplify}
  \begin{enumerate}
    \item $\mathtt{(\alpha <: Obj(eq : [Bot] \rightarrow Bot),\ \beta)}$
    \item $\mathtt{(\alpha <: Obj(hash : [\ ] \rightarrow Bot),\ \gamma)}$
    \item $\mathtt{(\gamma <: Bot)}$
  \end{enumerate}
\end{ej}


El siguiente paso es agrupar las restricciones sobre la misma variable de tipo, usando las reglas de la proposición \ref{teo1}. Aplicando el algoritmo \ref{pseudogroup}, el conjunto de restricciones del ejemplo \ref{ejsimplify} se reduce a solo dos restricciones, lo que se muestra en el ejemplo \ref{ej3-2}.


\begin{ej}\
  \normalfont
  \label{ej3-2}
  \begin{enumerate}
    \item $\mathtt{(\alpha <: Obj(eq : [Bot] \rightarrow Bot) \sqcap Obj(hash : [\ ] \rightarrow Bot))}$
    \item $\mathtt{(\gamma <: Bot)}$
  \end{enumerate}
\end{ej}
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Agrupación de restricciones. La entrada \texttt{cs} es un conjunto de restricciones, y \texttt{typeVariables} es una lista de variables de tipo. La función asigna a $\mathtt{c_1}$ una restricción que en su lado derecho posee un constructor de tipos $\sqcap$, y a $\mathtt{c_2}$ una restricción que en su lado izquierdo posee un constructor de tipos $\sqcup$. La salida es un conjunto de restricciones con a lo más dos restricciones.}
  \label{pseudogroup}
    \begin{algorithmic}[1]
      \Function{Group}{\texttt{cs, typeVariables}}
          \State $\mathtt{newCs\gets \{\}}$
          \For {\texttt{tvar \textbf{in} typeVariables}}
            \State $\mathtt{c_1\gets Constraint(tvar, \sqcap())}$
            \State $\mathtt{c_2\gets Constraint(\sqcup(), tvar)}$
            \For {\texttt{constraint \textbf{in} cs}}
              \If {$\mathtt{constraint.left == tvar}$}
                \State $\mathtt{c_1.right.insert(constraint.right)}$
              \EndIf
              \If {$\mathtt{constraint.right == tvar}$}
                \State $\mathtt{c_2.left.insert(constraint.left)}$
              \EndIf
            \EndFor
            \If {$\mathtt{c_1.right.notEmpty()}$}
              \State $\mathtt{newCs.insert(c_1)}$
            \EndIf
            \If {$\mathtt{c_2.left.notEmpty()}$}
              \State $\mathtt{newCs.insert(c_2)}$
            \EndIf
          \EndFor
          \State \Return $\mathtt{newCs}$
      \EndFunction
    \end{algorithmic}
\end{algorithm}


\subsection{Unificación}
En este paso, se construyen tipos utilizando las operaciones \texttt{meet} y \texttt{join} sobre los tipos $\sqcap$ y $\sqcup$ que relacionan tipos concretos, lo que significa calcular la unión y la intersección respectivamente entre los tipos relacionados. Además, se comprueba la validez de las restricciones y se realizan substituciones de forma iterativa.

\subsubsection{Meet y Join}
Cuando se tiene un tipo $\mathtt{t_1 \sqcap t_2}$ o $\mathtt{t_1 \sqcup t_2}$, donde $\mathtt{t_1}$ y $\mathtt{t_2}$ no tienen variables de tipo, entonces se puede construir el tipo correspondiente. Este procedimiento se muestra en el algoritmo \ref{pseudoperations}. La operación \texttt{meet} consiste en la unión de los métodos en $\mathtt{t_1}$ y $\mathtt{t_2}$, y \texttt{join} consiste en la intersección de los métodos en $\mathtt{t_1}$ y $\mathtt{t_2}$.

Si aplicamos el algoritmo \ref{pseudoperations} al conjunto de restricciones del ejemplo \ref{ej3-2}, se construye el tipo del lado derecho de la restricción 1. Esto se muestra en el ejemplo \ref{ejmater}.
\begin{ej}\
  \normalfont
  \label{ejmater}
  \begin{enumerate}
    \item $\mathtt{(\alpha <: Obj(eq : [Bot] \rightarrow Bot, hash : [\ ] \rightarrow Bot))}$
    \item $\mathtt{(\gamma <: Bot)}$
  \end{enumerate}
\end{ej}


\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Construcción de tipos. La entrada es un conjunto de restricciones.}
  \label{pseudoperations}
    \begin{algorithmic}[1]
      \Function{performOperations}{\texttt{cs}}
          \For {\texttt{constraint \textbf{in} cs}}
            \Switch{constraint.right}
              \Case{$\mathtt{t_1 \sqcap t_2}$}
                \State $\mathtt{constraint.right\gets Obj(t_1.methods \cup t_2.methods)}$
              \EndCase
            \EndSwitch
            \Switch{constraint.left}
              \Case{$\mathtt{t_1 \sqcup t_2}$}
                \State $\mathtt{constraint.left\gets Obj(t_1.methods \cap t_2.methods)}$
              \EndCase
            \EndSwitch
          \EndFor
      \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsubsection{Verificación de restricciones} \label{propuestaVer}
Cuando una restricción que proviene de una invocación a método representa una relación no válida, se debe reemplazar por \texttt{Top} toda aparición del tipo de expresión de la restricción, en el conjunto de restricciones, debido a la aplicación de la regla $\text{TmH}$ de la desclasificación basada en tipos. Si la restricción no proviene de una invocación a método y representa una relación no válida, se debe reportar un error de seguridad. En el ejemplo \ref{ej-tmh}, las restricciones relevantes generadas son:

\begin{enumerate}
  \item $(\mathtt{Top <: Obj(eq: Bot \rightarrow Bot),\ \alpha})$
  \item $(\mathtt{\alpha <: \beta})$
\end{enumerate}

Donde $\beta$ es la faceta pública de retorno de \texttt{login}. Como la restricción 1 representa una relación no válida y proviene de invocación a método, el tipo de expresión $\alpha$ debe substituirse por \texttt{Top} en el conjunto de restricciones. Luego, la restricción 2 cambia a $(\mathtt{Top <: \beta})$.

El algoritmo \ref{pseudocheck} muestra la verificación de restricciones. Este algoritmo usa la función \texttt{substitute}, que se muestra en el algoritmo \ref{pseudosubstitute}.
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Verificación de restricciones. La entrada \texttt{cs} es un conjunto de restricciones, y la salida \texttt{errorCollector} es una lista de errores.}
  \label{pseudocheck}
    \begin{algorithmic}[1]
      \Function{checkConstraints}{\texttt{cs}}
          \State $\mathtt{errorCollector\gets \{\}}$
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.isNotValid() \textbf{and} constraint.isFromMethodInvocation()}}
              \For {\texttt{c \textbf{in} cs}}
                \State $\mathtt{c.left\gets substitute(c.left,\ constraint.expressionType,\ Top)}$
                \State $\mathtt{c.right\gets substitute(c.right,\ constraint.expressionType,\ Top)}$
              \EndFor
            \ElsIf {\texttt{constraint.isNotValid()}}
              \State \texttt{errorCollector.insert(SubtypingError)}
            \EndIf
          \EndFor
          \State \Return $\mathtt{errorCollector}$
      \EndFunction
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Substitución dentro de tipos. La salida es el tipo \texttt{source} con toda aparición de \texttt{target} reemplazada por \texttt{newType}.}
    \begin{algorithmic}[1]
      \label{pseudosubstitute}
      \Function{substitute}{\texttt{source,target,newType}}
          \If {\texttt{source == target}}
            \State \Return \texttt{newType}
          \EndIf
          \Switch{\texttt{source}}
            \Case{\texttt{Obj(members)}}
              \State \Return \texttt{Obj(members.map((l,s) => {l: substitute(s,target,newType)}))}
            \EndCase
            \Case{$\mathtt{x \rightarrow y}$}
              \State \Return $\mathtt{substitute(x,target,newType)\rightarrow substitute(y,target,newType)}$
            \EndCase
            \Case{$\mathtt{x \sqcap y}$}
              \State \Return $\mathtt{substitute(x,target,newType) \sqcap substitute(y,target,newType)}$
            \EndCase
            \Case{$\mathtt{x \sqcup y}$}
              \State \Return $\mathtt{substitute(x,target,newType) \sqcup substitute(y,target,newType)}$
            \EndCase
            \Case{$\alpha$}
              \State \Return $\alpha$
            \EndCase
          \EndSwitch
      \State \Return \texttt{source}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
\clearpage

\subsubsection{Substitución}
Cuando se tiene una restricción que relaciona una variable de tipo con un tipo concreto, se debe substituir en el conjunto de restricciones toda aparición de la variable de tipo, por el tipo concreto. Como este proceso puede generar nuevas restricciones que sean candidatas a construcción de nuevos tipos, a verificación o a substitución, se debe iterar hasta que no queden restricciones candidatas. El algoritmo \ref{pseudosubst} muestra la substitución de restricciones resueltas, mientras que el algoritmo \ref{pseudouni} muestra el procedimiento completo de unificación.


\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Substitución de restricciones. La entrada es un conjunto de restricciones, y la salida es un diccionario entre variables de tipo y tipos concretos.}
  \label{pseudosubst}
    \begin{algorithmic}[1]
      \Function{substituteResolved}{\texttt{cs}}
          \State $\mathtt{m\gets \{\}}$
          \For {\texttt{constraint \textbf{in} cs}}
            \If {\texttt{constraint.right.isConcrete() \textbf{and} constraint.left.isVariable()}}
              \For {\texttt{c \textbf{in} cs, c != constraint}}
                \State $\mathtt{c.left\gets substitute(c.left,\ constraint.left,\ constraint.right)}$
                \State $\mathtt{c.right\gets substitute(c.right,\ constraint.left,\ constraint.right)}$
              \EndFor
              \State $\mathtt{m[constraint.left]\gets constraint.right}$
              \State \texttt{cs.remove(constraint)}
            \EndIf
            \If {\texttt{constraint.left.isConcrete() \textbf{and} constraint.right.isVariable()}}
              \For {\texttt{c \textbf{in} cs, c != constraint}}
                \State $\mathtt{c.left\gets substitute(c.left,\ constraint.right,\ constraint.left)}$
                \State $\mathtt{c.right\gets substitute(c.right,\ constraint.right,\ constraint.left)}$
              \EndFor
              \State $\mathtt{m[constraint.right]\gets constraint.left}$
              \State \texttt{cs.remove(constraint)}
            \EndIf
          \EndFor
          \State \Return \texttt{m}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
\clearpage
\begin{algorithm}\captionsetup{labelsep=newline}
  \centering
  \caption{Unificación. La entrada es un conjunto de restricciones, y la salida es una dupla con un diccionario entre variables de tipo y tipos concretos, y una lista de errores.}
  \label{pseudouni}
    \begin{algorithmic}[1]
      \Function{Unify}{\texttt{cs}}
          \State $\mathtt{m\gets \{\}}$
          \State $\mathtt{errorCollector\gets \{\}}$
          \While {\texttt{cs.hasOperationCandidates() \textbf{or} cs.hasSubstCandidates()}}
            \State \texttt{performOperations(cs)}
            \State \texttt{checkConstraints(cs, errorCollector)}
            \State \texttt{m.addAll(substitueResolved(cs))}
          \EndWhile
          \State \Return \texttt{m, errorCollector}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
La función de unificación retorna un mapeo entre cada variable de tipo y un tipo concreto. El caso de que queden variables de tipo sin resolver significa que cualquier faceta pública sirve para validar la expresión según las reglas del sistema de tipos.

\section*{Resumen}
En este capítulo se describió la propuesta de un sistema de inferencia heurístico para la desclasificación basada en tipos. Este sistema se basa en la inferencia en sistemas Hindley-Milner, con variaciones en el paso de resolución de restricciones para tratar con restricciones sobre subtipos. En el próximo capítulo se describen detalles de la implementación en Dart.
