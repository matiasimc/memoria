\begin{intro}
		La protección de la confidencialidad de la información manipulada por los programas computacionales es un problema cuya relevancia se ha incrementado en el último tiempo, a pesar de tener varias décadas de investigación.Por ejemplo, una aplicación web (o móvil) que como parte de su funcionamiento debe interactuar con servicios de terceros y por tanto debe proteger que su información sensible no se escape durante la ejecución de la aplicación a canales públicos.

		Muchas de las técnicas de seguridad convencionales como \textit{control de acceso} tienen deficiencias para proteger la confidencialidad de un programa, por ejemplo no restringen la propagación de información []. % TODO citation needed

		Formas más expresivas y efectivas de proteger la confidencialidad se basan en un análisis, ya sea estático o dinámico, sobre el código del programa, y se categorizan dentro de \textit{language-based security} (LBS). En este trabajo, nos centraremos en la verificación estática de que un programa protege la confidencialidad de su información.

		\paragraph{Tipado de seguridad}
		Una de las técnicas más efectivas de LBS con análisis estático es \textit{tipado de seguridad} en un \textit{lenguaje de seguridad}. En un lenguaje de seguridad, los valores y los tipos son anotados con niveles de seguridad para clasificar la información que el programa manipula. Dichos niveles de seguridad forman una\textit{lattice} \footnote{Un orden parcial, donde todo par de elementos tiene un único supremo e ínfimo}. Por ejemplo con la \textit{lattice} de dos niveles de seguridad $L \sqsubseteq H$, se puede distinguir entre valores enteros públicos o de baja confidencialidad ($Int_L$) y valores enteros privados o de alta confidencialidad ($Int_H$). El sistema de tipos usa estos niveles de seguridad para prevenir que la información confidencial no fluya directa o indirectamente hacia canales públicos []. % TODO citation needed

		\paragraph{No-interferencia}
		Formalmente, la propiedad de confidencialidad puede ser expresada como una propiedad de \textit{no-interferencia (noninterference)}. A grandes rasgos noninterference expresa que para dos ejecuciones realizadas por el adversario de un programa seguro, con valores confidenciales equivalentes, las salidas del programa deben ser equivalentes para el adversario. Esto caracteriza que el adversario no aprende nada sobre los valores confidenciales de un programa.

		El siguiente programa ilustra el concepto de noninterference. Este muestra un método \texttt{login} para verificar la contraseña de un usuario. Se considera que el parámetro \texttt{password} es privado (y por tanto no provisto por el adversario), mientras que el parámetro \texttt{guess} es público (y lo provee el adversario).

		\begin{lstlisting}
	String login(String password, String guess) {
		if (password == guess) return "Login Successful";
		else return "Login failed";
	}
		\end{lstlisting}

		Este programa no cumple noninterference, pues el adversario puede aprender sobre la variable confidencial \texttt{password} observando el valor de retorno del método para distintas ejecuciones.

		\paragraph{Declasificación}
		En una aplicación real y práctica deseamos que el programa anterior sea aceptado a pesar de violar la propiedad de no-interferencia, pues de otra forma no tendríamos cómo realizar la autenticación. Para solucionar este problema, los lenguajes de seguridad adicionan mecanismos para \textit{declasificar} la información confidencial, implementados de diferentes formas []. Una de ellas, por ejemplo en Jif (un lenguaje de seguridad) [] es usar un operador \texttt{declassify}, como se indica en el siguiente ejemplo, declasificando la comparación de igualdad del parámetro confidencial \texttt{password} con el parámetro público \texttt{guess} %TODO citation needed.

		\begin{lstlisting}
	String login(String password, String guess) {
		if (declassify(password == guess)) return "Login Successful";
		else return "Login failed";
	}
		\end{lstlisting}

		Esto no corresponde a una amenaza de seguridad, debido a que el resultado de la operación de comparación es negligible con respecto al parámetro privado \texttt{password}. Sin embargo, usos arbitrarios del operador \texttt{declassify} pueden resultar en serias fugas de información, como por ejemplo \texttt{declassify(password)}.

		Varios mecanismos se han explorado para controlar el uso de declasificación, y poder asegurar además una propiedad de seguridad para el programa []. En esta dirección, Cruz et al. [] recientemente propusieron \textit{type-based declassification} como un mecanismo de declasificación que conecta la abstracción de tipos con una forma controlada de declasificación, en una manera intuitiva y expresiva, proveyendo garantías formales sobre la seguridad del programa. %TODO citation needed.


\end{intro}
