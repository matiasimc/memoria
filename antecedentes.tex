\chapter{Control de flujo de información} \label{controlflujo}
El control de flujo de información es una técnica de seguridad que permite controlar las acciones que se pueden realizar con los valores que manipula un programa, y hacia dónde está permitido que fluyan. En este capítulo se presentan los antecedentes de tipado de seguridad para el control de flujo de información, y los conceptos importantes de la desclasificación basada en tipos.

\section{Tipado de seguridad}
Los lenguajes con tipado de seguridad para el control del flujo de la información clasifican los valores de un programa con respecto a sus niveles de confidencialidad, expresado mediante un retículo\footnote{Un orden parcial, donde todo par de elementos tiene un único supremo e ínfimo} (\emph{lattice}) de etiquetas de seguridad. Por ejemplo, con el retículo de dos niveles de seguridad \texttt{L} $\sqsubseteq$ \texttt{H} se puede distinguir entre valores públicos o de baja confidencialidad (\texttt{L}) y valores privados o de alta confidencialidad (\texttt{H}). Un sistema de tipos con control de flujo asegura de forma estática el cumplimiento de la propiedad de no-interferencia~\cite{noninterference}, esto es, que la información confidencial no fluya directa o indirectamente hacia canales públicos~\cite{volpanoAl:S96}.

A modo de ejemplo, consideremos una aplicación móvil que permite encontrar un hotel cercano utilizando Google Maps, y luego reservar una habitación en ese hotel ingresando los datos de la tarjeta de crédito. La información confidencial involucrada en este caso son los datos de la tarjeta de crédito, que deben ser enviados al hotel para realizar la reserva. En el ejemplo \ref{ej2-1} se muestra el código de una función \texttt{book} que realiza la reserva, y las funciones \texttt{sendToHotel} y \texttt{sendToGoogleMaps} que envían información a los respectivos servicios.
\clearpage
\begin{ej} \ \\
  \normalfont
  \label{ej2-1}
\begin{lstlisting}
  String book(String username, int date, int cardNumber) {
    return sendToHotel(username, date, cardNumber);
  }

  String sendToHotel(String username, int date, int cardNumber);
  String sendToGoogleMaps(String token, int xCoord, int yCoord);
\end{lstlisting}
\end{ej}

La función \texttt{book} del ejemplo \ref{ej2-1} no contiene fugas de información confidencial. Sin embargo, el programador puede cometer un error y llamar a la función \texttt{sendToGoogleMaps} en lugar de \texttt{sendToHotel}, con los mismos argumentos. El programa resultante estaría bien tipado, pero introduce una severa fuga de información confidencial al enviar el número de la tarjeta de crédito a Google. El uso de tipado de seguridad permitiría prevenir esta fuga de información, mediante la anotación del parámetro \texttt{cardNumber} de la función \texttt{book} con un nivel de seguridad de alta confidencialidad, y el parámetro \texttt{yCoord} de la función \texttt{sendToGoogleMaps} con un nivel de seguridad de baja confidencialidad. Esto se muestra en el ejemplo \ref{ej2-2}.

\begin{ej} \ \\
  \normalfont
  \label{ej2-2}
\begin{lstlisting}
  String@L book(String@L username, int@L date, int@H cardNumber) {
    return sentToGoogleMaps(username, date, cardNumber); /* error */
  }

  String@L sendToHotel(String@L username, int@L date, int@H cardNumber);
  String@L sendToGoogleMaps(String@H token, int@L xCoord, int@L yCoord);
\end{lstlisting}
\end{ej}

El programa del ejemplo \ref{ej2-2} es rechazado por el sistema de tipos, debido a un error causado por el llamado a la función \texttt{sendToGoogleMaps}, donde se disminuye el nivel de seguridad de \texttt{cardNumber} desde \texttt{H} a \texttt{L}, lo cual es una infracción a la propiedad de no-interferencia.

Los flujos de información que ocurren en la asignación directa de valores se denominan \emph{flujos explícitos}. Para la detección de flujos explícitos que violan la propiedad de no-interferencia, los lenguajes con tipado de seguridad poseen distintas reglas que relacionan los niveles de seguridad involucrados. En una instrucción de asignación \texttt{x = y}, el nivel de seguridad de \texttt{y} debe ser igual o menor que el nivel de seguridad de \texttt{x}. En una instrucción de retorno \texttt{return y}, el nivel de seguridad de \texttt{y} debe ser igual o menor que el nivel de seguridad declarado como retorno de la función. En un llamado a una función, como ocurre en el ejemplo \ref{ej2-2}, el nivel de seguridad de cada argumento debe ser menor o igual que el nivel de seguridad del correspondiente parámetro.

Existen otros flujos de información que ocurren mediante la influencia indirecta que tienen algunas instrucciones o acciones del programa sobre su estado, denominados \emph{flujos implicitos}. En el ejemplo \ref{ej2-3} se muestra una función de \texttt{login} anotada con niveles de seguridad. Se considera que los valores literales son de baja confidencialidad.

\begin{ej} \ \\
  \normalfont
  \label{ej2-3}
\begin{lstlisting}
  String@L login(String@L guess, String@H password) {
    if (password == guess) return "Login successful";
    else return "Login failed";
  }
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej2-3} ocurre un flujo implícito que infringe con la propiedad de no-interferencia, debido a que un observador público puede obtener información del parámetro confidencial \texttt{password} observando cambios en el valor de retorno de la función, mediante el control de flujo del programa.

Es posible detectar un flujo implícito inválido considerando que las instrucciones de retorno y asignación de valores de baja confidencialidad, ocurren en un contexto de alta confidencialidad, determinado por la condición de la instrucción \texttt{if}. Para considerar el contexto de ejecución de una instrucción en las reglas del sistema de tipos, se utiliza el concepto de \emph{contexto de seguridad}~\cite{pc}, usualmente llamado \texttt{pc} por \emph{program counter}. Así, en el ejemplo \ref{ej2-3} las instrucciones de retorno son inválidas, debido a que retornan valores de baja confidencialidad cuando el contexto de seguridad tiene un valor de alta confidencialidad.

\section{Desclasificación}
A pesar de que no-interferencia es una propiedad atractiva para la especificación de sistemas seguros, se considera muy estricta en la práctica, debido a que impide que la información confidencial tenga cualquier tipo de influencia en una salida observable de un programa. En efecto, queremos que el programa de \texttt{login} del ejemplo \ref{ej2-3} sea aceptado a pesar de no cumplir con la propiedad, pues de otra forma no tendríamos cómo realizar la autenticación.

Para solucionar este problema, los lenguajes de seguridad adicionan mecanismos de desclasificación que disminuyen el nivel de seguridad de un valor confidencial, implementados de diferentes formas~\cite{sabelfeldSands:JCS09}. Una de ellas, por ejemplo en Jif~\cite{jif} es usar un operador \texttt{declassify}, que desclasifica un valor de alta confidencialidad retornando un valor de baja confidencialidad. En el ejemplo \ref{ej2-4}, se utiliza para desclasificar el resultado de la operación de comparación.

\begin{ej} \ \\
  \normalfont
  \label{ej2-4}
\begin{lstlisting}
  String@L login(String@L guess, String@H password) {
    if (declassify(password == guess)) return "Login Successful";
    else return "Login failed";
  }
\end{lstlisting}
\end{ej}


A pesar de que este programa no cumple con no-interferencia, no representa una amenaza de seguridad, debido a que el resultado de la operación de comparación es negligible con respecto al parámetro privado \texttt{password}. Sin embargo, usos arbitrarios del operador \texttt{declassify} pueden resultar en serias fugas de información. Por ejemplo, \texttt{declassify(password)} puede dar conocimiento absoluto sobre el valor de la variable a un observador público.

Varios mecanismos se han explorado para controlar el uso de desclasificación, y poder asegurar además una propiedad de seguridad para el programa~\cite{sabelfeldSands:JCS09}. Por ejemplo, mediante la definición de políticas globales de desclasificación~\cite{liZdancewic:POPL05} se asegura una versión relajada de la propiedad de no-interferencia. En esta dirección, Cruz et al.~\cite{cruzAl:ecoop2017} recientemente propusieron la desclasificación basada en tipos como un mecanismo de desclasificación que conecta la abstracción de tipos con una forma controlada de desclasificación, en una manera intuitiva y expresiva, proveyendo garantías formales sobre la seguridad del programa.

En la desclasificación basada en tipos, los tipos tienen dos facetas; la faceta privada, que refleja el tipo de implementación, y la faceta pública, que refleja las operaciones de desclasificación sobre los valores de dicho tipo. Por ejemplo, el tipo $\mathtt{StringEq} \triangleq [\mathtt{eq} : \mathtt{String} \rightarrow \mathtt{Bool}]$\footnote{La notación $[\mathtt{m1} : \mathtt{t_1} \rightarrow \mathtt{t_2}, \mathtt{m2} : \mathtt{t_3} \rightarrow \mathtt{t_4}]$ corresponde al tipo de un objeto que contiene a los métodos \texttt{m1} y \texttt{m2}, y la notación $\mathtt{t_1} \rightarrow \mathtt{t_2}$ corresponde al tipo de una función con parámetro de tipo $t_1$ y retorno de tipo $t_2$} autoriza la operación \texttt{eq} sobre un \texttt{String}. Entonces se puede usar el tipo de dos facetas \texttt{String<StringEq}, donde \texttt{String} es la faceta privada y \texttt{StringEq} es la faceta pública, para controlar la operación de desclasificación de la igualdad sobre \texttt{password}, lo que se muestra en el ejemplo \ref{ej2-5}.

\begin{ej} \ \\
  \normalfont
  \label{ej2-5}
\begin{lstlisting}
  String<String login(String<String guess, String<StringEq password) {
  	if (password.eq(guess)) return "Login successful";
  	else return "Login failed";
  }
\end{lstlisting}
\end{ej}


En la desclasificación basada en tipos, se cumple que la faceta privada es subtipo de la faceta pública. En el ejemplo \ref{ej2-5}, \texttt{String} es subtipo de \texttt{StringEq}, relación que se escribe como \texttt{String <: StringEq}. Los tipos que cumplen con esta restricción se denominan bien formados (\emph{well-formed}).

Al igual que en tipado de seguridad de dos o más niveles, las facetas de la desclasificación basada en tipos forman un retículo con relaciones de subtipos, lo que se ejemplifica en la figura \ref{l1}. Si la faceta pública coincide con la faceta privada, toda operación sobre el valor estará autorizada. Cuando esto sucede, se refiere usualmente a la faceta pública con \texttt{Bot}, por encontrarse siempre en la parte inferior del retículo. Cuando se quiere referir a una faceta pública vacía o que no autoriza ninguna operación, se usa \texttt{Top}, por encontrarse en la parte superior del retículo.

\clearpage
	\begin{figure}[ht]
		\centering
		\begin{tikzpicture}[node distance=2.3cm]
			\node(Top) 												{\texttt{Top} $\triangleq [\ ]$};
			\node(StringEq)		[below right=0.7cm and 0.1cm of Top]			{\texttt{StringEq} $\triangleq [\mathtt{eq} : \mathtt{String} \rightarrow \mathtt{Bool}]$};
			\node(StringEqLength)      [below of=StringEq]       {\texttt{StringEqLength} $\triangleq [\mathtt{eq} : \mathtt{String} \rightarrow \mathtt{Bool}, \mathtt{length} : \mathtt{Unit} \rightarrow \mathtt{Int}]$};
			\node(String)				[below of=StringEqLength]       {\texttt{String} $\triangleq [\mathtt{eq} : \mathtt{String} \rightarrow \mathtt{Bool}, \mathtt{length} : \mathtt{Unit} \rightarrow \mathtt{Int},\ ...]$};
			\node(int)					[below left=0.7cm and 0.1cm of Top] 			{\texttt{Int} $\triangleq [\mathtt{abs} : \mathtt{Unit} \rightarrow \mathtt{Int},\ ...]$};
			\draw(Top)      -- (StringEq);
			\draw(Top)      -- (int);
			\draw(StringEq)      -- (StringEqLength);
			\draw(StringEqLength)      -- (String);
		\end{tikzpicture}
		\caption{Retículo de subtipos}
    \label{l1}
	\end{figure}

Los métodos declarados en la faceta pública también poseen tipos de dos facetas en sus firmas. Así, el tipo \texttt{StringEq} visto anteriormente se define como $\mathtt{StringEq} \triangleq [\mathtt{eq} : \mathtt{String}$\texttt{<}$\mathtt{String} \rightarrow \mathtt{Bool}$\texttt{<}$\mathtt{Bool}]$.

Existen dos reglas principales para comprobar que un programa con tipos de dos facetas se encuentra bien tipado. Consideremos el siguiente ejemplo, en donde $\mathtt{StringHashEq} \triangleq [\mathtt{hash} : \mathtt{Unit}$\texttt{<}$\mathtt{Unit} \rightarrow \mathtt{String}$\texttt{<}$\mathtt{StringEq}]$.

\begin{ej} \ \\
  \normalfont
  \label{ej2-6}
\begin{lstlisting}
  String<StringEq getHash(String<StringHashEq password) {
  	return password.hash();
  }
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej2-6}, el valor de retorno de la invocación al método \texttt{hash} sobre el parámetro \texttt{password}, tiene faceta pública \texttt{StringEq}, debido a que fue declarado de esta forma en la faceta pública \texttt{StringHashEq}. A esta regla se le llama $\text{TmD}$ y se muestra en la figura \ref{reglas}.

Ahora consideremos el siguiente ejemplo, en donde se cambia la faceta pública del parámetro \texttt{password} del ejemplo \ref{ej2-6} por \texttt{StringEq}.

\begin{ej} \ \\
  \normalfont
  \label{ej2-7}
\begin{lstlisting}
  String<Top getHash(String<StringEq password) {
  	return password.hash();
  }
\end{lstlisting}
\end{ej}

\clearpage
En el ejemplo \ref{ej2-7} se realiza una invocación al método \texttt{hash} sobre el parámetro \texttt{password}, que declara una faceta pública que no autoriza la operación. Cuando esto sucede, la faceta pública de retorno de la invocación es \texttt{Top}. A esta regla se le llama $\text{TmH}$ y se muestra en la figura \ref{reglas}.

\begin{figure}[ht]
  \centering
  \[
    \infer[(\text{TmD})]
    {\Gamma \vdash e_1.m(e_2) : S_2}
    {
    \Gamma \vdash e_1 : T\text{\texttt{<}}U&
    \highlight{m\in U}&
    \mathtt{methsig}(U,m) = S_1 \rightarrow S_2&
    \Gamma \vdash e_2 : S_1
    }
  \]
  \[
    \infer[(\text{TmH})]
    {\Gamma \vdash e_1.m(e_2) : T_2\text{\texttt{<}}\highlight{\top}}
    {
    \Gamma \vdash e_1 : T\text{\texttt{<}}U&
    \highlight{m\notin U}&
    \mathtt{methsig}(T,m) = S_1 \rightarrow T_2\text{\texttt{<}}U_2&
    \Gamma \vdash e_2 : S_1
    }
  \]
  \caption{Reglas principales del sistema de tipos de la desclasificación basada en tipos. Cada regla se compone de una serie de premisas en la parte superior, y una conclusión en la parte inferior. El juicio de la forma $\Gamma \vdash e : T$ indica que en el contexto $\Gamma$ la expresión $e$ tiene tipo $T$. El procedimiento auxiliar \texttt{methsig}$(O,m)$ entrega la firma del método $m$ en el tipo de objeto $O$. Un tipo $S$ es un tipo de dos facetas $T\text{\texttt{<}}U$.}
  \label{reglas}
\end{figure}

La propiedad de seguridad que se demuestra para el sistema de tipos de la desclasificación basada en tipos es una forma de no-interferencia con políticas de desclasificación, denominada no-interferencia relajada (\emph{relaxed noninterference}). Un lenguaje de seguridad que cumple con esta propiedad, garantiza que la información confidencial solo puede fluir hacia canales públicos de forma controlada, por medio de las políticas de desclasificación.

En este capítulo se revisaron los conceptos de control de flujo de información y tipado de seguridad, incluyendo la desclasificación basada en tipos. Es importante considerar que la implementación de un lenguaje de programación con el sistema de tipos de la desclasificación basada en tipos, requiere la anotación de los identificadores con facetas públicas y privadas, lo cual es poco práctico. Por este motivo es deseable contar con un sistema de inferencia de tipos para la desclasificación basada en tipos. En el siguiente capítulo se revisan los conceptos importantes de inferencia de tipos.

\chapter{Inferencia de tipos} \label{inference}
La inferencia de tipos es el proceso de determinar el tipo de las expresiones en un programa, basado en cómo son usadas. Tener un mecanismo de inferencia en un lenguaje de programación puede ser muy útil, debido a que da la posibilidad al programador de omitir las declaraciones de tipo para algunos identificadores, y mantener los beneficios de un lenguaje estáticamente tipado. Además, aumenta la escalabilidad de los sistemas, ya que el costo de refactorizar código anotado es mayor al costo de refactorizar código no anotado.

\section{Inferencia en lenguajes conocidos}
Las características de los sistemas de inferencia varían dependiendo de las características de los lenguajes de programación. A continuación se describe la inferencia de tipos en lenguajes conocidos.

\paragraph{Scala.} Scala es un lenguaje de programación estáticamente\footnote{Un lenguaje estáticamente tipado es aquel que comprueba en tiempo de compilación la correctitud de los tipos del programa} tipado que combina los paradigmas de la programación orientada a objetos y la programación funcional. Scala posee una inferencia de tipos local~\cite{pierce}, que permite omitir las anotaciones de tipos en la declaración de variables locales, en el uso de clases y métodos polimórficos, y en el tipo de retorno de métodos no recursivos. Esto se muestra en el ejemplo \ref{ejscala}, donde se infiere el tipo de los identificadores \texttt{p} y \texttt{q}.
\clearpage
\begin{ej} \ \\
  \normalfont
  \label{ejscala}
\begin{lstlisting}[language=Scala]
  case class MyPair[A, B](x: A, y: B);
  object InferenceTest {
    def id[T](x: T) = x
    val p = MyPair(1, "scala")   // type: MyPair[Int, String]
    val q = id(1)                 // type: Int
  }
\end{lstlisting}
\end{ej}

\paragraph{Haskell.} Haskell es un lenguaje de programación funcional estáticamente tipado, cuyo sistema de tipos se basa en el sistema de tipos Hindley-Milner (HM)~\cite{damasmilner}. Este sistema de tipos tiene inferencia global, es decir, es capaz de inferir los tipos principales\footnote{Un tipo principal es el tipo más general que puede ser inferido para una expresión, en el sentido de que cualquier otro tipo posible es una especialización del tipo principal} en un programa sin ninguna anotación de tipo. Haskell es capaz de inferir tipos con polimorfismo paramétrico, lo que significa que se pueden declarar funciones polimórficas como en Java y Scala sin necesidad de indicar un tipo genérico. En el ejemplo \ref{haskellpoly} se muestra la definición de la función \texttt{map} en Haskell, y el tipo inferido en la última línea. Este tipo corresponde al tipo de una función, que dado una función de tipo $\mathtt{a \rightarrow b}$ y una lista de tipo \texttt{a}, retorna una lista de tipo \texttt{b}.

\begin{ej} \ \\
  \normalfont
  \label{haskellpoly}
\begin{lstlisting}[language=Haskell]
  map f [] = []
  map f (first:rest) = f first : map f rest

  >:t map
  map :: (a -> b) -> [a] -> [b]
\end{lstlisting}
\end{ej}

\paragraph{C++.} C++ es un lenguaje de programación orientado a objetos estáticamente tipado que posee herramientas para realizar programación de bajo nivel. C++ ofrece la posibilidad de omitir el tipo en la declaración de variables mediante los keywords \texttt{auto} y \texttt{decltype}, lo que se muestra en el ejemplo \ref{ejc}.

\begin{ej} \ \\
  \normalfont
  \label{ejc}
\begin{lstlisting}[language=C,morekeywords={decltype,string}]
  auto n = 1;      // type: int
  string s = "abc";
  decltype(s) k;  // type: string
\end{lstlisting}
\end{ej}

\section{Inferencia en sistemas Hindley-Milner}

Un sistema de tipos de Hindley-Milner (HM)~\cite{damasmilner} es un sistema de tipos clásico del cálculo lambda con polimorfismo paramétrico. El algoritmo de inferencia del sistema de tipos HM, denominado algoritmo W, siempre calcula el tipo principal de las expresiones. En esta sección se explica el proceso de inferencia de tipos para un lenguaje sencillo de tipo HM, con el fin de ilustrar los conceptos importantes de inferencia de tipos.

El lenguaje a considerar posee operaciones aritméticas entre enteros y funciones. La sintaxis se muestra en el ejemplo \ref{ej2-8}.

\vspace{0.8em}
\begin{ej}
  \normalfont
  \label{ej2-8}
\begin{lstlisting}
  let g = (x) => x + 5;
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej2-8}, se asigna a \texttt{g} una función que retorna la suma entre \texttt{x} y \texttt{5}. Notar que no se anotó el tipo de los identificadores \texttt{g} y \texttt{x}.

En la etapa de tipar un programa (\emph{type checking}), los sistemas de inferencia asignan una variable de tipo a cada expresión sin un tipo conocido, y un tipo concreto\footnote{Un tipo concreto no tiene variables de tipo} (por ejemplo, \texttt{int}) a cada expresión con tipo conocido. Además, generan un conjunto de restricciones que se deben cumplir para que cada expresión esté bien tipada.

Una restricción representa una relación entre dos tipos. Esta relación puede ser de igualdad o de subtipos. El uso de restricciones permite presentar un algoritmo de inferencia de forma modular, como una fase de generación de restricciones, y una fase de resolución de restricciones.

La figura \ref{tabla1} muestra la asignación de tipos a cada una de las expresiones del ejemplo \ref{ej2-8}, y las restricciones que se generan.


\begin{figure}[ht]
  \centering
  \ttfamily
  \begin{tabular}{c c c}
    Expresión & Tipo & Restricciones\\
    \hline
    (x) =>\ x + 5 & X & $\mathtt{X = Y \rightarrow Z}$\\
    x & Y & -\\
    x + 5 & Z & Y = int, Z = int\\
    + & $\mathtt{(int,int) \rightarrow int}$ & -\\
    x & Y & -\\
    5 & int & -\\
  \end{tabular}
  \caption{Etapa de \emph{type checking}}
  \label{tabla1}
\end{figure}

Las restricciones generadas para el ejemplo \ref{ej2-8} representan la igualdad entre dos tipos. Las siguientes observaciones permiten derivar el conjunto de restricciones del programa.

\begin{enumerate}
  \item \texttt{(x) =>\ x + 5} es una función anónima que debe tener tipo $\mathtt{Y \rightarrow Z}$, donde \texttt{Y} es el tipo del parámetro y \texttt{Z} es el tipo del cuerpo.
  \item \texttt{x + 5} es una aplicación de la función suma, por lo que su tipo debe coincidir con el tipo de retorno de la función. Además, el tipo de los argumentos debe coincidir con el tipo de los parámetros de la función.
\end{enumerate}

Sintetizando, el conjunto de restricciones generado es el siguiente:

\begin{itemize}
  \item $\mathtt{X = Y \rightarrow Z}$
  \item \texttt{Y = int}
  \item \texttt{Z = int}
\end{itemize}

Una vez que se genera el conjunto de restricciones sobre el programa, se procede a encontrar una solución para las variables de tipo del conjunto. Cuando las restricciones representan relaciones de igualdad, se utiliza el algoritmo de unificación de Hindley-Milner~\cite{damasmilner}. Este algoritmo genera un diccionario de variables de tipo a tipos concretos, mediante substituciones. La figura \ref{tabla2} muestra la solución esperada del ejemplo \ref{ej2-8}.

\begin{figure}[ht]
  \centering
  \ttfamily
  \begin{tabular}{c c}
    Variable de tipo & Tipo concreto \\
    \hline
    X & $\mathtt{int \rightarrow int}$  \\
    Y & int \\
    Z & int \\
  \end{tabular}
  \caption{Solución del conjunto de restricciones}
  \label{tabla2}
\end{figure}

Desafortunadamente, el algoritmo de unificación de Hindley-Milner no funciona cuando las restricciones representan una relación de subtipos. Consideremos una extensión del lenguaje anterior,  en donde se introducen los tipos \texttt{num} y \texttt{float}, donde se cumple \texttt{float <: num} y \texttt{int <: num}. En el ejemplo \ref{ej2-9} se muestran dos instrucciones de asignación.
\vspace{0.8em}
\begin{ej}
  \normalfont
  \label{ej2-9}
\begin{lstlisting}
  let f = 4;
                ...
                f = 1.5;
\end{lstlisting}
\end{ej}

En el ejemplo \ref{ej2-9}, se asigna la variable de tipo \texttt{X} al identificador \texttt{f}. Las restricciones que se generan para las instrucciones de asignación son:

\begin{itemize}
  \item \texttt{int <: X}
  \item \texttt{float <: X}
\end{itemize}

%Cardelli~\cite{cardelli}

Para resolver este tipo de restricciones, se considera la relación de orden parcial entre los tipos, inducida por la relación de subtipos, que se muestra en la figura \ref{subt1}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[node distance=2.3cm]
    \node(num) 												{\texttt{num}};
    \node(int)		[below right of=num]			{\texttt{int}};
    \node(float)					[below left of=num] 			{\texttt{float}};
    \draw (num)      -- (int);
    \draw (num)      -- (float);
  \end{tikzpicture}
  \caption{Orden parcial entre los tipos}
  \label{subt1}
\end{figure}

Un orden parcial admite las operaciones \texttt{meet} y \texttt{join}, que corresponden a la máxima cota inferior (ínfimo) y a la mínima cota superior (supremo) entre dos tipos, respectivamente. Estas operaciones tienen solución si todo par de tipos en el orden parcial tiene un único supremo e ínfimo, lo que se define como retículo. En la figura \ref{subt1}, se debe agregar el tipo \texttt{Bot} para que el orden parcial sea un retículo.

Luego, mediante los tipos $\mathtt{t_1 \sqcap t_2}$ y $\mathtt{t_1 \sqcup t_2}$ introducidos por Cardelli~\cite{cardelli}, se representan las operaciones \texttt{meet} y \texttt{join} entre dos tipos, respectivamente.

En la fase de resolución de restricciones, se aplican las reglas de la proposición \ref{teo1} para generar los tipos correspondientes. Luego, cuando los tipos $\sqcap$ y $\sqcup$ relacionan tipos concretos, se puede materializar la operación sobre el retículo.

%Pese a que Cardelli no considera una inferencia basada en constraints, se puede aplicar este enfoque para la resolución de constraints de subtyping. En efecto, Pottier~\cite{pottier:inria-00073205} y Sekiguchi~\cite{sekiguchi} presentan sistemas de inferencia basados en constraints, con tipos equivalentes a los \texttt{meet} y \texttt{join} de Cardelli.

\begin{prop} \label{teo1} \normalfont Si \texttt{x}, \texttt{y} y \texttt{z} pertenecen a una retículo de subtipos, se cumple lo siguiente:
  \begin{itemize}
    \item \texttt{x <: y}, \texttt{x <: z} $\implies$ $\mathtt{x <: y \sqcap z}$
    \item \texttt{y <: x}, \texttt{z <: x} $\implies$ $\mathtt{y \sqcup z <: x}$
  \end{itemize}
\end{prop}

En el ejemplo \ref{ej2-9}, las restricciones generadas se reducen con la aplicación de la proposición \ref{teo1}, lo que da como resultado la restricción $\mathtt{int\sqcup float <: X}$. Como \texttt{int} y \texttt{float} son tipos concretos, se puede materializar la operación \texttt{join}, lo que da como resultado \texttt{num}.

Finalmente, como la restricción \texttt{num <: X} solo admite una solución para \texttt{X}, se resuelve que \texttt{X} tiene tipo \texttt{num}.

A lo largo del tiempo se han desarrollado diversas extensiones al sistema de tipos HM, para brindar características avanzadas manteniendo la completitud del algoritmo W. Odersky et al.~\cite{odersky} desarrollaron el framework HM(X), que entrega un algoritmo de inferencia genérico para cualquier sistema de tipos basado en restricciones, que cumpla con ciertas propiedades. Utilizando el framework HM(X), Pottier y Simonet~\cite{Pottier} presentaron un análisis de control de flujo con inferencia de tipos de seguridad.

En este capítulo se presentó la inferencia de tipos, se mostraron algunos ejemplos de lenguajes conocidos que utilizan alguna forma de inferencia, y se explicaron los conceptos básicos de inferencia utilizando un sistema Hindley-Milner. En el siguiente capítulo se propone un algoritmo de inferencia para la desclasificación basada en tipos.

% \subsection*{Antecedentes adicionales}
%
% \subsubsection*{Relación de subtipos}
%
% En el ejemplo \ref{ej2-9}, la relación de subtipos es nominal. En una relación de subtipos nominal, el retículo de subtipos es definido explícitamente por el programador o el lenguaje de programación. El ejemplo \ref{ej2-10} muestra una declaración explícita de un retículo de subtipos, mediante el uso del \emph{keyword} \texttt{extends}.
%
% \begin{ej} \ \\
%   \normalfont
%   \label{ej2-10}
% \begin{lstlisting}
%   class Animal {
%     String getName();
%   }
%   class Duck extends Animal {
%     void cuack();
%   }
%   class Cat extends Animal {
%     void miau();
%   }
% \end{lstlisting}
% \end{ej}
%
% Cuando una relación de subtipos es estructural, el retículo de subtipos se define por la forma que tienen los tipos. El ejemplo \ref{ej2-11} muestra la declaración de las clases que definen una relación de subtipos estructural.
%
% \begin{ej} \ \\
%   \normalfont
%   \label{ej2-11}
% \begin{lstlisting}
%   class Animal {
%     String getName();
%   }
%   class Duck {
%     String getName();
%     void cuack();
%   }
%   class Cat {
%     String getName();
%     void miau();
%   }
% \end{lstlisting}
% \end{ej}


%Los tipos $\sqcap$ y $\sqcup$ fueron utilizados por vez primera en un algoritmo de inferencia por Cardelli~\cite{cardelli}.

% Teniendo en cuenta que los distintos sistemas de inferencia propuestos a lo largo del tiempo comparten características, Odersky \textit{et al.}~\cite{odersky} propusieron el framework \texttt{HM(X)}, que entrega un algoritmo de inferencia genérico para un sistema de tipos basado en constraints que cumpla ciertas condiciones.

% Utilizando el framework \texttt{HM(X)}, Pottier y Simonet~\cite{Pottier} presentaron un análisis de control de flujo con inferencia de tipos de seguridad, que hereda todas las buenas propiedades de \texttt{HM(X)}.
